<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.production">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.production" />
              <option name="originalContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://username:password@hostname:port/database&#10;&#10;# Telegram Bot (ваши реальные данные)&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://your-app-name.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO&#10;" />
              <option name="updatedContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda-backend.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM python:3.12&#10;WORKDIR /app&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;RUN pip install fastapi uvicorn sqlalchemy psycopg2-binary feedparser requests apscheduler aiohttp&#10;" />
              <option name="updatedContent" value="FROM python:3.12&#10;WORKDIR /app&#10;COPY requirements.txt .&#10;RUN pip install -r requirements.txt&#10;COPY . .&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile.render" />
              <option name="updatedContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;USER appuser&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/public/index.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/public/index.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;ru&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;utf-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no&quot; /&gt;&#10;    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;&#10;    &lt;meta name=&quot;description&quot; content=&quot;Gift Propaganda News - новости о подарках, криптовалютах и NFT в Telegram&quot; /&gt;&#10;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;&#10;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;&#10;&#10;    &lt;!-- Telegram Web App SDK --&gt;&#10;    &lt;script src=&quot;https://telegram.org/js/telegram-web-app.js&quot;&gt;&lt;/script&gt;&#10;&#10;    &lt;title&gt;Gift Propaganda News&lt;/title&gt;&#10;&#10;    &lt;style&gt;&#10;      html, body {&#10;        margin: 0;&#10;        padding: 0;&#10;        height: 100%;&#10;        overflow-x: hidden;&#10;      }&#10;&#10;      body {&#10;        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',&#10;          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',&#10;          sans-serif;&#10;        -webkit-font-smoothing: antialiased;&#10;        -moz-osx-font-smoothing: grayscale;&#10;        background-color: var(--tg-theme-bg-color, #ffffff);&#10;        color: var(--tg-theme-text-color, #000000);&#10;      }&#10;&#10;      #root {&#10;        height: 100%;&#10;      }&#10;&#10;      /* Telegram Web App specific styles */&#10;      .twa-viewport {&#10;        height: 100vh;&#10;        height: var(--tg-viewport-height, 100vh);&#10;      }&#10;    &lt;/style&gt;&#10;  &lt;/head&gt;&#10;  &lt;body&gt;&#10;    &lt;noscript&gt;Вам необходимо включить JavaScript для работы этого приложения.&lt;/noscript&gt;&#10;    &lt;div id=&quot;root&quot; class=&quot;twa-viewport&quot;&gt;&lt;/div&gt;&#10;&#10;    &lt;script&gt;&#10;      // Инициализация Telegram Web App&#10;      if (window.Telegram &amp;&amp; window.Telegram.WebApp) {&#10;        window.Telegram.WebApp.ready();&#10;        window.Telegram.WebApp.expand();&#10;&#10;        // Применяем CSS переменные Telegram&#10;        const root = document.documentElement;&#10;        const tgWebApp = window.Telegram.WebApp;&#10;&#10;        if (tgWebApp.themeParams) {&#10;          Object.keys(tgWebApp.themeParams).forEach(key =&gt; {&#10;            root.style.setProperty(`--tg-theme-${key.replace(/_/g, '-')}`, tgWebApp.themeParams[key]);&#10;          });&#10;        }&#10;&#10;        // Устанавливаем высоту viewport&#10;        if (tgWebApp.viewportHeight) {&#10;          root.style.setProperty('--tg-viewport-height', `${tgWebApp.viewportHeight}px`);&#10;        }&#10;      }&#10;    &lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;ru&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;utf-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no&quot; /&gt;&#10;    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;&#10;    &lt;meta name=&quot;description&quot; content=&quot;Gift Propaganda News - новости о подарках, криптовалютах и NFT в Telegram&quot; /&gt;&#10;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;&#10;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;&#10;&#10;    &lt;!-- Telegram Web App SDK --&gt;&#10;    &lt;script src=&quot;https://telegram.org/js/telegram-web-app.js&quot;&gt;&lt;/script&gt;&#10;&#10;    &lt;title&gt;Gift Propaganda News&lt;/title&gt;&#10;&#10;    &lt;style&gt;&#10;      /* CSS переменные для Telegram Web App */&#10;      :root {&#10;        --tg-theme-bg-color: #ffffff;&#10;        --tg-theme-text-color: #000000;&#10;        --tg-theme-hint-color: #8e8e93;&#10;        --tg-theme-link-color: #007aff;&#10;        --tg-theme-button-color: #007aff;&#10;        --tg-theme-button-text-color: #ffffff;&#10;        --tg-theme-secondary-bg-color: #f8f9fa;&#10;        --tg-viewport-height: 100vh;&#10;      }&#10;&#10;      /* Темная тема для Telegram */&#10;      @media (prefers-color-scheme: dark) {&#10;        :root {&#10;          --tg-theme-bg-color: #212121;&#10;          --tg-theme-text-color: #ffffff;&#10;          --tg-theme-hint-color: #8e8e93;&#10;          --tg-theme-link-color: #6ab7ff;&#10;          --tg-theme-button-color: #5288c1;&#10;          --tg-theme-button-text-color: #ffffff;&#10;          --tg-theme-secondary-bg-color: #181818;&#10;        }&#10;      }&#10;&#10;      html, body {&#10;        margin: 0;&#10;        padding: 0;&#10;        height: 100%;&#10;        overflow-x: hidden;&#10;      }&#10;&#10;      body {&#10;        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',&#10;          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',&#10;          sans-serif;&#10;        -webkit-font-smoothing: antialiased;&#10;        -moz-osx-font-smoothing: grayscale;&#10;        background-color: var(--tg-theme-bg-color, #ffffff);&#10;        color: var(--tg-theme-text-color, #000000);&#10;      }&#10;&#10;      #root {&#10;        height: 100%;&#10;      }&#10;&#10;      /* Telegram Web App specific styles */&#10;      .twa-viewport {&#10;        height: 100vh;&#10;        height: var(--tg-viewport-height, 100vh);&#10;      }&#10;    &lt;/style&gt;&#10;  &lt;/head&gt;&#10;  &lt;body&gt;&#10;    &lt;noscript&gt;Вам необходимо включить JavaScript для работы этого приложения.&lt;/noscript&gt;&#10;    &lt;div id=&quot;root&quot; class=&quot;twa-viewport&quot;&gt;&lt;/div&gt;&#10;&#10;    &lt;script&gt;&#10;      // Инициализация Telegram Web App&#10;      if (window.Telegram &amp;&amp; window.Telegram.WebApp) {&#10;        window.Telegram.WebApp.ready();&#10;        window.Telegram.WebApp.expand();&#10;&#10;        // Применяем CSS переменные Telegram&#10;        const root = document.documentElement;&#10;        const tgWebApp = window.Telegram.WebApp;&#10;&#10;        if (tgWebApp.themeParams) {&#10;          Object.keys(tgWebApp.themeParams).forEach(key =&gt; {&#10;            root.style.setProperty(`--tg-theme-${key.replace(/_/g, '-')}`, tgWebApp.themeParams[key]);&#10;          });&#10;        }&#10;&#10;        // Устанавливаем высоту viewport&#10;        if (tgWebApp.viewportHeight) {&#10;          root.style.setProperty('--tg-viewport-height', `${tgWebApp.viewportHeight}px`);&#10;        }&#10;      }&#10;    &lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx" />
              <option name="originalContent" value="import React, { useState, useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;&#10;const AppContainer = styled.div`&#10;  background-color: #f5f5f5;&#10;  min-height: 100vh;&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;&#10;  color: #333;&#10;  padding: 20px;&#10;`;&#10;&#10;const Header = styled.header`&#10;  background-color: #0088cc;&#10;  color: white;&#10;  padding: 15px;&#10;  text-align: center;&#10;  border-radius: 10px 10px 0 0;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;`;&#10;&#10;const NewsList = styled.ul`&#10;  list-style: none;&#10;  padding: 0;&#10;  margin: 20px 0;&#10;`;&#10;&#10;const NewsItemCard = styled.li`&#10;  background-color: white;&#10;  padding: 15px;&#10;  margin-bottom: 10px;&#10;  border-radius: 10px;&#10;  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);&#10;  transition: transform 0.2s;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-2px);&#10;  }&#10;`;&#10;&#10;const Title = styled.h2`&#10;  color: #0088cc;&#10;  margin: 0 0 10px;&#10;  font-size: 1.2em;&#10;`;&#10;&#10;const Content = styled.p`&#10;  color: #666;&#10;  margin: 5px 0;&#10;  font-size: 0.9em;&#10;`;&#10;&#10;const SourceLink = styled.a`&#10;  color: #bbb;&#10;  font-size: 0.75em;&#10;  display: block;&#10;  margin-top: 10px;&#10;  text-decoration: none;&#10;  word-break: break-all;&#10;&#10;  &amp;:hover {&#10;    text-decoration: underline;&#10;    color: #888;&#10;  }&#10;`;&#10;&#10;const CategoryDate = styled.p`&#10;  color: #999;&#10;  font-size: 0.8em;&#10;  margin: 5px 0 0;&#10;`;&#10;&#10;const Message = styled.p`&#10;  text-align: center;&#10;  color: #666;&#10;`;&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsResponse&gt;({ status: 'success', data: [], message: '' });&#10;&#10;  useEffect(() =&gt; {&#10;    const getNews = async () =&gt; {&#10;      const data = await fetchNews();&#10;      setNews(data);&#10;    };&#10;    getNews();&#10;    const interval = setInterval(getNews, 60000); // Обновление каждую минуту&#10;    return () =&gt; clearInterval(interval); // Очистка при размонтировании&#10;  }, []);&#10;&#10;  return (&#10;    &lt;AppContainer&gt;&#10;      &lt;Header&gt;&#10;        &lt;h1&gt;Новости от Telegram&lt;/h1&gt;&#10;      &lt;/Header&gt;&#10;      {news.status === 'success' ? (&#10;        news.data.length &gt; 0 ? (&#10;          &lt;NewsList&gt;&#10;            {news.data.map((item: NewsItem) =&gt; (&#10;              &lt;NewsItemCard key={item.id}&gt;&#10;                &lt;Title&gt;{item.title}&lt;/Title&gt;&#10;                &lt;Content&gt;{item.content}&lt;/Content&gt;&#10;                &lt;CategoryDate&gt;&#10;                  Категория: {item.category} | Дата: {new Date(item.publish_date).toLocaleDateString()}&#10;                &lt;/CategoryDate&gt;&#10;                {item.link &amp;&amp; (&#10;                  &lt;SourceLink href={item.link} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#10;                    Источник&#10;                  &lt;/SourceLink&gt;&#10;                )}&#10;              &lt;/NewsItemCard&gt;&#10;            ))}&#10;          &lt;/NewsList&gt;&#10;        ) : (&#10;          &lt;Message&gt;{news.message}&lt;/Message&gt;&#10;        )&#10;      ) : (&#10;        &lt;Message&gt;Ошибка загрузки новостей&lt;/Message&gt;&#10;      )}&#10;    &lt;/AppContainer&gt;&#10;  );&#10;};&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import styled, { ThemeProvider, createGlobalStyle } from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;import TelegramWebApp from './telegram/TelegramWebApp';&#10;&#10;// Глобальные стили для Telegram Mini App&#10;const GlobalStyle = createGlobalStyle&lt;{ theme: any }&gt;`&#10;  * {&#10;    margin: 0;&#10;    padding: 0;&#10;    box-sizing: border-box;&#10;  }&#10;&#10;  body {&#10;    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;&#10;    background-color: ${props =&gt; props.theme.bg_color || '#ffffff'};&#10;    color: ${props =&gt; props.theme.text_color || '#000000'};&#10;    overflow-x: hidden;&#10;    -webkit-font-smoothing: antialiased;&#10;    -moz-osx-font-smoothing: grayscale;&#10;  }&#10;&#10;  html, body, #root {&#10;    height: 100%;&#10;    margin: 0;&#10;    padding: 0;&#10;  }&#10;`;&#10;&#10;const AppContainer = styled.div&lt;{ theme: any }&gt;`&#10;  background-color: ${props =&gt; props.theme.bg_color || '#ffffff'};&#10;  min-height: 100vh;&#10;  color: ${props =&gt; props.theme.text_color || '#000000'};&#10;  padding: 0;&#10;  margin: 0;&#10;`;&#10;&#10;const Header = styled.header&lt;{ theme: any }&gt;`&#10;  background-color: ${props =&gt; props.theme.secondary_bg_color || props.theme.bg_color || '#f8f9fa'};&#10;  color: ${props =&gt; props.theme.text_color || '#000000'};&#10;  padding: 16px;&#10;  text-align: center;&#10;  border-bottom: 1px solid ${props =&gt; props.theme.hint_color || '#e0e0e0'};&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;`;&#10;&#10;const Title = styled.h1&lt;{ theme: any }&gt;`&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  margin: 0;&#10;  color: ${props =&gt; props.theme.text_color || '#000000'};&#10;`;&#10;&#10;const NewsList = styled.div`&#10;  padding: 8px;&#10;`;&#10;&#10;const NewsItemCard = styled.div&lt;{ theme: any }&gt;`&#10;  background-color: ${props =&gt; props.theme.secondary_bg_color || '#ffffff'};&#10;  margin-bottom: 8px;&#10;  border-radius: 12px;&#10;  overflow: hidden;&#10;  border: 1px solid ${props =&gt; props.theme.hint_color || '#e0e0e0'};&#10;  transition: transform 0.1s ease;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.98);&#10;  }&#10;`;&#10;&#10;const NewsContent = styled.div`&#10;  padding: 16px;&#10;`;&#10;&#10;const NewsTitle = styled.h2&lt;{ theme: any }&gt;`&#10;  color: ${props =&gt; props.theme.link_color || '#007AFF'};&#10;  margin: 0 0 8px 0;&#10;  font-size: 16px;&#10;  font-weight: 600;&#10;  line-height: 1.3;&#10;`;&#10;&#10;const NewsText = styled.p&lt;{ theme: any }&gt;`&#10;  color: ${props =&gt; props.theme.text_color || '#000000'};&#10;  margin: 8px 0;&#10;  font-size: 14px;&#10;  line-height: 1.4;&#10;`;&#10;&#10;const NewsInfo = styled.div&lt;{ theme: any }&gt;`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  margin-top: 12px;&#10;  padding-top: 8px;&#10;  border-top: 1px solid ${props =&gt; props.theme.hint_color || '#e0e0e0'};&#10;`;&#10;&#10;const CategoryBadge = styled.span&lt;{ theme: any }&gt;`&#10;  background-color: ${props =&gt; props.theme.button_color || '#007AFF'};&#10;  color: ${props =&gt; props.theme.button_text_color || '#ffffff'};&#10;  padding: 4px 8px;&#10;  border-radius: 6px;&#10;  font-size: 12px;&#10;  font-weight: 500;&#10;`;&#10;&#10;const DateText = styled.span&lt;{ theme: any }&gt;`&#10;  color: ${props =&gt; props.theme.hint_color || '#8E8E93'};&#10;  font-size: 12px;&#10;`;&#10;&#10;const SourceLink = styled.button&lt;{ theme: any }&gt;`&#10;  background: none;&#10;  border: none;&#10;  color: ${props =&gt; props.theme.hint_color || '#8E8E93'};&#10;  font-size: 11px;&#10;  text-decoration: none;&#10;  padding: 4px 0;&#10;  cursor: pointer;&#10;  margin-top: 8px;&#10;&#10;  &amp;:active {&#10;    opacity: 0.6;&#10;  }&#10;`;&#10;&#10;const Message = styled.div&lt;{ theme: any }&gt;`&#10;  text-align: center;&#10;  padding: 32px 16px;&#10;  color: ${props =&gt; props.theme.hint_color || '#8E8E93'};&#10;  font-size: 14px;&#10;`;&#10;&#10;const LoadingSpinner = styled.div&lt;{ theme: any }&gt;`&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  padding: 32px;&#10;  color: ${props =&gt; props.theme.hint_color || '#8E8E93'};&#10;`;&#10;&#10;const CategoryFilter = styled.div`&#10;  padding: 8px 16px;&#10;  display: flex;&#10;  gap: 8px;&#10;  overflow-x: auto;&#10;  -webkit-overflow-scrolling: touch;&#10;`;&#10;&#10;const FilterButton = styled.button&lt;{ active: boolean; theme: any }&gt;`&#10;  background-color: ${props =&gt; props.active &#10;    ? props.theme.button_color || '#007AFF' &#10;    : props.theme.secondary_bg_color || '#f0f0f0'};&#10;  color: ${props =&gt; props.active &#10;    ? props.theme.button_text_color || '#ffffff' &#10;    : props.theme.text_color || '#000000'};&#10;  border: none;&#10;  padding: 8px 16px;&#10;  border-radius: 18px;&#10;  font-size: 14px;&#10;  font-weight: 500;&#10;  white-space: nowrap;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsResponse&gt;({ status: 'success', data: [], message: '' });&#10;  const [loading, setLoading] = useState(true);&#10;  const [selectedCategory, setSelectedCategory] = useState('all');&#10;  const [telegramTheme, setTelegramTheme] = useState&lt;any&gt;({});&#10;&#10;  const categories = [&#10;    { key: 'all', name: 'Все' },&#10;    { key: 'gifts', name: 'Подарки' },&#10;    { key: 'crypto', name: 'Крипто' },&#10;    { key: 'nft', name: 'NFT' },&#10;    { key: 'tech', name: 'Технологии' },&#10;    { key: 'community', name: 'Сообщество' }&#10;  ];&#10;&#10;  useEffect(() =&gt; {&#10;    // Инициализация Telegram Web App&#10;    if (TelegramWebApp.isAvailable()) {&#10;      const theme = TelegramWebApp.getTheme();&#10;      setTelegramTheme(theme.themeParams);&#10;      &#10;      // Показываем главную кнопку для закрытия&#10;      TelegramWebApp.showMainButton('Закрыть', () =&gt; {&#10;        TelegramWebApp.close();&#10;      });&#10;    }&#10;&#10;    // Загрузка новостей&#10;    getNews();&#10;    const interval = setInterval(getNews, 300000); // Обновление каждые 5 минут&#10;    return () =&gt; clearInterval(interval);&#10;  }, [selectedCategory]);&#10;&#10;  const getNews = async () =&gt; {&#10;    setLoading(true);&#10;    try {&#10;      const data = await fetchNews();&#10;      setNews(data);&#10;      &#10;      // Фильтруем по категории на клиенте&#10;      if (selectedCategory !== 'all' &amp;&amp; data.data) {&#10;        const filtered = data.data.filter(item =&gt; item.category === selectedCategory);&#10;        setNews({ ...data, data: filtered });&#10;      }&#10;    } catch (error) {&#10;      console.error('Error fetching news:', error);&#10;      setNews({ status: 'error', data: [], message: 'Ошибка загрузки новостей' });&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleCategoryChange = (category: string) =&gt; {&#10;    if (TelegramWebApp.isAvailable()) {&#10;      TelegramWebApp.hapticFeedback('light');&#10;    }&#10;    setSelectedCategory(category);&#10;  };&#10;&#10;  const handleSourceClick = (url: string) =&gt; {&#10;    if (TelegramWebApp.isAvailable()) {&#10;      TelegramWebApp.hapticFeedback('medium');&#10;      TelegramWebApp.openLink(url);&#10;    } else {&#10;      window.open(url, '_blank');&#10;    }&#10;  };&#10;&#10;  const formatDate = (dateString: string) =&gt; {&#10;    const date = new Date(dateString);&#10;    const now = new Date();&#10;    const diffMs = now.getTime() - date.getTime();&#10;    const diffMins = Math.floor(diffMs / 60000);&#10;    const diffHours = Math.floor(diffMins / 60);&#10;    const diffDays = Math.floor(diffHours / 24);&#10;&#10;    if (diffMins &lt; 60) {&#10;      return `${diffMins} мин назад`;&#10;    } else if (diffHours &lt; 24) {&#10;      return `${diffHours} ч назад`;&#10;    } else if (diffDays &lt; 7) {&#10;      return `${diffDays} дн назад`;&#10;    } else {&#10;      return date.toLocaleDateString('ru-RU');&#10;    }&#10;  };&#10;&#10;  const getCategoryName = (category: string) =&gt; {&#10;    const cat = categories.find(c =&gt; c.key === category);&#10;    return cat ? cat.name : category;&#10;  };&#10;&#10;  return (&#10;    &lt;ThemeProvider theme={telegramTheme}&gt;&#10;      &lt;GlobalStyle theme={telegramTheme} /&gt;&#10;      &lt;AppContainer theme={telegramTheme}&gt;&#10;        &lt;Header theme={telegramTheme}&gt;&#10;          &lt;Title theme={telegramTheme}&gt;Gift Propaganda News&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;&#10;        &lt;CategoryFilter&gt;&#10;          {categories.map(category =&gt; (&#10;            &lt;FilterButton&#10;              key={category.key}&#10;              active={selectedCategory === category.key}&#10;              theme={telegramTheme}&#10;              onClick={() =&gt; handleCategoryChange(category.key)}&#10;            &gt;&#10;              {category.name}&#10;            &lt;/FilterButton&gt;&#10;          ))}&#10;        &lt;/CategoryFilter&gt;&#10;&#10;        {loading ? (&#10;          &lt;LoadingSpinner theme={telegramTheme}&gt;&#10;            Загрузка новостей...&#10;          &lt;/LoadingSpinner&gt;&#10;        ) : news.status === 'success' ? (&#10;          news.data.length &gt; 0 ? (&#10;            &lt;NewsList&gt;&#10;              {news.data.map((item: NewsItem) =&gt; (&#10;                &lt;NewsItemCard key={item.id} theme={telegramTheme}&gt;&#10;                  &lt;NewsContent&gt;&#10;                    &lt;NewsTitle theme={telegramTheme}&gt;{item.title}&lt;/NewsTitle&gt;&#10;                    &lt;NewsText theme={telegramTheme}&gt;{item.content}&lt;/NewsText&gt;&#10;                    &#10;                    &lt;NewsInfo theme={telegramTheme}&gt;&#10;                      &lt;CategoryBadge theme={telegramTheme}&gt;&#10;                        {getCategoryName(item.category)}&#10;                      &lt;/CategoryBadge&gt;&#10;                      &lt;DateText theme={telegramTheme}&gt;&#10;                        {formatDate(item.publish_date)}&#10;                      &lt;/DateText&gt;&#10;                    &lt;/NewsInfo&gt;&#10;                    &#10;                    {item.link &amp;&amp; (&#10;                      &lt;SourceLink&#10;                        theme={telegramTheme}&#10;                        onClick={() =&gt; handleSourceClick(item.link)}&#10;                      &gt;&#10;                        Источник&#10;                      &lt;/SourceLink&gt;&#10;                    )}&#10;                  &lt;/NewsContent&gt;&#10;                &lt;/NewsItemCard&gt;&#10;              ))}&#10;            &lt;/NewsList&gt;&#10;          ) : (&#10;            &lt;Message theme={telegramTheme}&gt;&#10;              {news.message || 'Нет новостей в выбранной категории'}&#10;            &lt;/Message&gt;&#10;          )&#10;        ) : (&#10;          &lt;Message theme={telegramTheme}&gt;&#10;            Ошибка загрузки новостей&#10;          &lt;/Message&gt;&#10;        )}&#10;      &lt;/AppContainer&gt;&#10;    &lt;/ThemeProvider&gt;&#10;  );&#10;};&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;const API_URL = 'https://giftpropaganda-backend.onrender.com/api/news/';  // Замените на ваш Render URL&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsResponse&gt;(API_URL, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true'&#10;      }&#10;    });&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: 'Ошибка загрузки новостей (frontend)'&#10;    };&#10;  }&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;const API_URL = 'https://giftpropaganda-backend.onrender.com/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsResponse&gt;(API_URL, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true'&#10;      }&#10;    });&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: 'Ошибка загрузки новостей (frontend)'&#10;    };&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts" />
              <option name="originalContent" value="// Telegram Web App SDK интеграция&#10;declare global {&#10;  interface Window {&#10;    Telegram: {&#10;      WebApp: {&#10;        initData: string;&#10;        initDataUnsafe: any;&#10;        version: string;&#10;        platform: string;&#10;        colorScheme: 'light' | 'dark';&#10;        themeParams: {&#10;          bg_color?: string;&#10;          text_color?: string;&#10;          hint_color?: string;&#10;          link_color?: string;&#10;          button_color?: string;&#10;          button_text_color?: string;&#10;          secondary_bg_color?: string;&#10;        };&#10;        isExpanded: boolean;&#10;        viewportHeight: number;&#10;        viewportStableHeight: number;&#10;        ready: () =&gt; void;&#10;        expand: () =&gt; void;&#10;        close: () =&gt; void;&#10;        MainButton: {&#10;          text: string;&#10;          color: string;&#10;          textColor: string;&#10;          isVisible: boolean;&#10;          isActive: boolean;&#10;          show: () =&gt; void;&#10;          hide: () =&gt; void;&#10;          enable: () =&gt; void;&#10;          disable: () =&gt; void;&#10;          onClick: (callback: () =&gt; void) =&gt; void;&#10;          offClick: (callback: () =&gt; void) =&gt; void;&#10;        };&#10;        BackButton: {&#10;          isVisible: boolean;&#10;          show: () =&gt; void;&#10;          hide: () =&gt; void;&#10;          onClick: (callback: () =&gt; void) =&gt; void;&#10;          offClick: (callback: () =&gt; void) =&gt; void;&#10;        };&#10;        HapticFeedback: {&#10;          impactOccurred: (style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft') =&gt; void;&#10;          notificationOccurred: (type: 'error' | 'success' | 'warning') =&gt; void;&#10;          selectionChanged: () =&gt; void;&#10;        };&#10;        showAlert: (message: string, callback?: () =&gt; void) =&gt; void;&#10;        showConfirm: (message: string, callback?: (confirmed: boolean) =&gt; void) =&gt; void;&#10;        openLink: (url: string, options?: { try_instant_view?: boolean }) =&gt; void;&#10;        requestWriteAccess: (callback?: (granted: boolean) =&gt; void) =&gt; void;&#10;        requestContact: (callback?: (granted: boolean, contact?: any) =&gt; void) =&gt; void;&#10;      };&#10;    };&#10;  }&#10;}&#10;&#10;export class TelegramWebApp {&#10;  private static instance: TelegramWebApp;&#10;  public webApp: any;&#10;&#10;  private constructor() {&#10;    this.webApp = window.Telegram?.WebApp;&#10;    if (this.webApp) {&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;    }&#10;  }&#10;&#10;  public static getInstance(): TelegramWebApp {&#10;    if (!TelegramWebApp.instance) {&#10;      TelegramWebApp.instance = new TelegramWebApp();&#10;    }&#10;    return TelegramWebApp.instance;&#10;  }&#10;&#10;  public isAvailable(): boolean {&#10;    return !!this.webApp;&#10;  }&#10;&#10;  public getTheme() {&#10;    if (!this.webApp) return { colorScheme: 'light', themeParams: {} };&#10;&#10;    return {&#10;      colorScheme: this.webApp.colorScheme || 'light',&#10;      themeParams: this.webApp.themeParams || {}&#10;    };&#10;  }&#10;&#10;  public getUserData() {&#10;    if (!this.webApp?.initDataUnsafe) return null;&#10;&#10;    return {&#10;      user: this.webApp.initDataUnsafe.user,&#10;      chat: this.webApp.initDataUnsafe.chat,&#10;      start_param: this.webApp.initDataUnsafe.start_param&#10;    };&#10;  }&#10;&#10;  public showMainButton(text: string, callback: () =&gt; void) {&#10;    if (!this.webApp?.MainButton) return;&#10;&#10;    this.webApp.MainButton.text = text;&#10;    this.webApp.MainButton.show();&#10;    this.webApp.MainButton.onClick(callback);&#10;  }&#10;&#10;  public hideMainButton() {&#10;    if (!this.webApp?.MainButton) return;&#10;    this.webApp.MainButton.hide();&#10;  }&#10;&#10;  public hapticFeedback(type: 'light' | 'medium' | 'heavy' = 'light') {&#10;    if (!this.webApp?.HapticFeedback) return;&#10;    this.webApp.HapticFeedback.impactOccurred(type);&#10;  }&#10;&#10;  public showAlert(message: string) {&#10;    if (!this.webApp?.showAlert) {&#10;      alert(message);&#10;      return;&#10;    }&#10;    this.webApp.showAlert(message);&#10;  }&#10;&#10;  public openLink(url: string) {&#10;    if (!this.webApp?.openLink) {&#10;      window.open(url, '_blank');&#10;      return;&#10;    }&#10;    this.webApp.openLink(url);&#10;  }&#10;&#10;  public close() {&#10;    if (!this.webApp?.close) return;&#10;    this.webApp.close();&#10;  }&#10;}&#10;&#10;export default TelegramWebApp.getInstance();&#10;" />
              <option name="updatedContent" value="// Telegram Web App SDK интеграция&#10;declare global {&#10;  interface Window {&#10;    Telegram: {&#10;      WebApp: {&#10;        initData: string;&#10;        initDataUnsafe: any;&#10;        version: string;&#10;        platform: string;&#10;        colorScheme: 'light' | 'dark';&#10;        themeParams: {&#10;          bg_color?: string;&#10;          text_color?: string;&#10;          hint_color?: string;&#10;          link_color?: string;&#10;          button_color?: string;&#10;          button_text_color?: string;&#10;          secondary_bg_color?: string;&#10;        };&#10;        isExpanded: boolean;&#10;        viewportHeight: number;&#10;        viewportStableHeight: number;&#10;        ready: () =&gt; void;&#10;        expand: () =&gt; void;&#10;        close: () =&gt; void;&#10;        MainButton: {&#10;          text: string;&#10;          color: string;&#10;          textColor: string;&#10;          isVisible: boolean;&#10;          isActive: boolean;&#10;          show: () =&gt; void;&#10;          hide: () =&gt; void;&#10;          enable: () =&gt; void;&#10;          disable: () =&gt; void;&#10;          onClick: (callback: () =&gt; void) =&gt; void;&#10;          offClick: (callback: () =&gt; void) =&gt; void;&#10;        };&#10;        BackButton: {&#10;          isVisible: boolean;&#10;          show: () =&gt; void;&#10;          hide: () =&gt; void;&#10;          onClick: (callback: () =&gt; void) =&gt; void;&#10;          offClick: (callback: () =&gt; void) =&gt; void;&#10;        };&#10;        HapticFeedback: {&#10;          impactOccurred: (style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft') =&gt; void;&#10;          notificationOccurred: (type: 'error' | 'success' | 'warning') =&gt; void;&#10;          selectionChanged: () =&gt; void;&#10;        };&#10;        showAlert: (message: string, callback?: () =&gt; void) =&gt; void;&#10;        showConfirm: (message: string, callback?: (confirmed: boolean) =&gt; void) =&gt; void;&#10;        openLink: (url: string, options?: { try_instant_view?: boolean }) =&gt; void;&#10;        requestWriteAccess: (callback?: (granted: boolean) =&gt; void) =&gt; void;&#10;        requestContact: (callback?: (granted: boolean, contact?: any) =&gt; void) =&gt; void;&#10;      };&#10;    };&#10;  }&#10;}&#10;&#10;export class TelegramWebApp {&#10;  private static instance: TelegramWebApp;&#10;  public webApp: any;&#10;&#10;  private constructor() {&#10;    this.webApp = window.Telegram?.WebApp;&#10;    if (this.webApp) {&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;    }&#10;  }&#10;&#10;  public static getInstance(): TelegramWebApp {&#10;    if (!TelegramWebApp.instance) {&#10;      TelegramWebApp.instance = new TelegramWebApp();&#10;    }&#10;    return TelegramWebApp.instance;&#10;  }&#10;&#10;  public isAvailable(): boolean {&#10;    return !!this.webApp;&#10;  }&#10;&#10;  public getTheme() {&#10;    if (!this.webApp) return { colorScheme: 'light', themeParams: {} };&#10;&#10;    return {&#10;      colorScheme: this.webApp.colorScheme || 'light',&#10;      themeParams: this.webApp.themeParams || {}&#10;    };&#10;  }&#10;&#10;  public getUserData() {&#10;    if (!this.webApp?.initDataUnsafe) return null;&#10;&#10;    return {&#10;      user: this.webApp.initDataUnsafe.user,&#10;      chat: this.webApp.initDataUnsafe.chat,&#10;      start_param: this.webApp.initDataUnsafe.start_param&#10;    };&#10;  }&#10;&#10;  public showMainButton(text: string, callback: () =&gt; void) {&#10;    if (!this.webApp?.MainButton) return;&#10;&#10;    this.webApp.MainButton.text = text;&#10;    this.webApp.MainButton.show();&#10;    this.webApp.MainButton.onClick(callback);&#10;  }&#10;&#10;  public hideMainButton() {&#10;    if (!this.webApp?.MainButton) return;&#10;    this.webApp.MainButton.hide();&#10;  }&#10;&#10;  public hapticFeedback(type: 'light' | 'medium' | 'heavy' = 'light') {&#10;    if (!this.webApp?.HapticFeedback) return;&#10;    &#10;    // Проверяем версию Telegram WebApp&#10;    const version = parseFloat(this.webApp.version || '6.0');&#10;    if (version &lt; 6.1) {&#10;      // В старых версиях хаптик не поддерживается&#10;      return;&#10;    }&#10;    &#10;    this.webApp.HapticFeedback.impactOccurred(type);&#10;  }&#10;&#10;  public showAlert(message: string) {&#10;    if (!this.webApp?.showAlert) {&#10;      alert(message);&#10;      return;&#10;    }&#10;    this.webApp.showAlert(message);&#10;  }&#10;&#10;  public openLink(url: string) {&#10;    if (!this.webApp?.openLink) {&#10;      window.open(url, '_blank');&#10;      return;&#10;    }&#10;    this.webApp.openLink(url);&#10;  }&#10;&#10;  public close() {&#10;    if (!this.webApp?.close) return;&#10;    this.webApp.close();&#10;  }&#10;}&#10;&#10;export default TelegramWebApp.getInstance();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="fastapi==0.104.1&#10;uvicorn[standard]==0.24.0&#10;sqlalchemy==2.0.23&#10;python-dotenv==1.0.0&#10;requests==2.31.0&#10;apscheduler==3.10.4&#10;aiohttp==3.9.1&#10;feedparser==6.0.10&#10;pydantic==2.5.0&#10;psycopg2-binary==2.9.9" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/.env" />
              <option name="updatedContent" value="# База данных&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=your_bot_token_here&#10;WEBHOOK_URL=https://your-domain.com/telegram_webhook&#10;&#10;# Redis (опционально)&#10;REDIS_URL=redis://localhost:6379&#10;&#10;# Другие настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/__init__.py" />
              <option name="updatedContent" value="# Server package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/__init__.py" />
              <option name="updatedContent" value="# API package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/news.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/news.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.main import app&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    SessionLocal = app.state.SessionLocal&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.db import SessionLocal  # Импортируем SessionLocal из db.py&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/config.py" />
              <option name="originalContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://user:password@db:5432/giftpropaganda&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)&#10;" />
              <option name="updatedContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных - исправлено для соответствия docker-compose.yml&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://user:password@db:5432/giftpropaganda&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/db.py" />
              <option name="updatedContent" value="from sqlalchemy import create_engine&#10;from sqlalchemy.orm import sessionmaker&#10;from server.config import DATABASE_URL&#10;from server.models import Base&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;&#10;# Создание таблиц (если нужно)&#10;Base.metadata.create_all(bind=engine)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Добавляем CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&#10;        &quot;http://localhost:3000&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;,&#10;        &quot;https://gift-propaganda.vercel.app&quot;,&#10;        &quot;https://*.onrender.com&quot;,  # Добавляем поддержку Render доменов&#10;        &quot;https://your-app-name.onrender.com&quot;  # Замените на ваш реальный домен&#10;    ],&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],  # Разрешаем все HTTP методы&#10;    allow_headers=[&quot;*&quot;],  # Разрешаем все заголовки&#10;)&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: WEBHOOK_URL}&#10;    response = requests.post(url, data=data)&#10;    if response.status_code == 200:&#10;        logger.info(&quot;Webhook установлен успешно&quot;)&#10;    else:&#10;        logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal  # Сохраняем SessionLocal&#10;    setup_webhook()&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()  # Создаём новую сессию&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()  # Закрываем сессию&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()  # Корректно закрываем engine&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
              <option name="updatedContent" value="from fastapi import FastAPI, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Добавляем CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&#10;        &quot;http://localhost:3000&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;,&#10;        &quot;https://gift-propaganda.vercel.app&quot;,&#10;        &quot;https://giftpropaganda-backend.onrender.com&quot;  # Обновлен для реального домена&#10;    ],&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],  # Разрешаем все HTTP методы&#10;    allow_headers=[&quot;*&quot;],  # Разрешаем все заголовки&#10;)&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: WEBHOOK_URL}&#10;    response = requests.post(url, data=data)&#10;    if response.status_code == 200:&#10;        logger.info(&quot;Webhook установлен успешно&quot;)&#10;    else:&#10;        logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal  # Сохраняем SessionLocal&#10;    setup_webhook()&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()  # Создаём новую сессию&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()  # Закрываем сессию&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()  # Корректно закрываем engine&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models.py" />
              <option name="originalContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;))  # Внешний ключ&#10;    title = Column(String(200), index=True)&#10;    content = Column(String)&#10;    link = Column(String(255))&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации&#10;" />
              <option name="updatedContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;), nullable=True)  # Внешний ключ теперь допускает NULL&#10;    title = Column(String(200), index=True)&#10;    content = Column(String)&#10;    link = Column(String(255))&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/__init__.py" />
              <option name="updatedContent" value="# Parsers package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/rss.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/rss.py" />
              <option name="updatedContent" value="import feedparser&#10;import logging&#10;from sqlalchemy.orm import Session&#10;from typing import List, Dict, Any&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;async def fetch_rss_feeds(session: Session) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Получение новостей из RSS источников&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Fetching RSS feeds...&quot;)&#10;        &#10;        # Список RSS источников&#10;        rss_sources = [&#10;            {&quot;url&quot;: &quot;https://vc.ru/rss&quot;, &quot;name&quot;: &quot;VC.ru&quot;, &quot;category&quot;: &quot;tech&quot;},&#10;            {&quot;url&quot;: &quot;https://forklog.com/feed/&quot;, &quot;name&quot;: &quot;ForkLog&quot;, &quot;category&quot;: &quot;crypto&quot;}&#10;        ]&#10;        &#10;        articles = []&#10;        for source in rss_sources:&#10;            try:&#10;                feed = feedparser.parse(source[&quot;url&quot;])&#10;                for entry in feed.entries[:5]:  # Берем только 5 последних&#10;                    article = {&#10;                        &quot;title&quot;: entry.title,&#10;                        &quot;link&quot;: entry.link,&#10;                        &quot;description&quot;: getattr(entry, 'summary', ''),&#10;                        &quot;source&quot;: source[&quot;name&quot;],&#10;                        &quot;category&quot;: source[&quot;category&quot;]&#10;                    }&#10;                    articles.append(article)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error parsing RSS {source['url']}: {e}&quot;)&#10;        &#10;        logger.info(f&quot;RSS feeds fetched successfully, {len(articles)} articles&quot;)&#10;        return articles&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Error fetching RSS feeds: {e}&quot;)&#10;        return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/utils/categorize.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/utils/categorize.py" />
              <option name="updatedContent" value="import re&#10;from typing import List, Dict&#10;&#10;def categorize_content(title: str, content: str = &quot;&quot;) -&gt; str:&#10;    &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;    &#10;    # Ключевые слова для категорий&#10;    keywords = {&#10;        'gifts': ['подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка', 'акция', 'розыгрыш'],&#10;        'crypto': ['криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф', 'defi', 'btc', 'eth'],&#10;        'nft': ['nft', 'нфт', 'токен', 'коллекция', 'opensea', 'digital art', 'метавселенная'],&#10;        'tech': ['технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап', 'ai', 'ии']&#10;    }&#10;    &#10;    text = (title + &quot; &quot; + content).lower()&#10;    &#10;    # Подсчитываем совпадения для каждой категории&#10;    category_scores = {}&#10;    for category, words in keywords.items():&#10;        score = sum(1 for word in words if word in text)&#10;        if score &gt; 0:&#10;            category_scores[category] = score&#10;    &#10;    if not category_scores:&#10;        return 'general'&#10;    &#10;    # Возвращаем категорию с наибольшим количеством совпадений&#10;    return max(category_scores, key=category_scores.get)&#10;&#10;def extract_keywords(text: str) -&gt; List[str]:&#10;    &quot;&quot;&quot;Извлечение ключевых слов из текста&quot;&quot;&quot;&#10;    # Простое извлечение слов длиннее 3 символов&#10;    words = re.findall(r'\b\w{4,}\b', text.lower())&#10;    return list(set(words))  # Уникальные слова" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>