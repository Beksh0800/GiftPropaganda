<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.production">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.production" />
              <option name="originalContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda-backend.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO&#10;" />
              <option name="updatedContent" value="# Production environment variables for Render&#10;# База данных - Render PostgreSQL&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda.onrender.com&#10;&#10;# Продакшен настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.env.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.render" />
              <option name="updatedContent" value="# Переменные окружения для Render&#10;DATABASE_URL=postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&#10;TELEGRAM_BOT_TOKEN=8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&#10;WEBHOOK_URL=https://giftpropaganda.onrender.com&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM python:3.12&#10;WORKDIR /app&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;RUN pip install fastapi uvicorn sqlalchemy psycopg2-binary feedparser requests apscheduler aiohttp&#10;" />
              <option name="updatedContent" value="FROM python:3.12&#10;WORKDIR /app&#10;COPY requirements.txt .&#10;RUN pip install -r requirements.txt&#10;COPY . .&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Dockerfile.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile.render" />
              <option name="originalContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;USER appuser&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;" />
              <option name="updatedContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска (переменные окружения будут переданы Render)&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/public/index.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/public/index.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;ru&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;utf-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no&quot; /&gt;&#10;    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;&#10;    &lt;meta name=&quot;description&quot; content=&quot;Gift Propaganda News - новости о подарках, криптовалютах и NFT в Telegram&quot; /&gt;&#10;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;&#10;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;&#10;&#10;    &lt;!-- Telegram Web App SDK --&gt;&#10;    &lt;script src=&quot;https://telegram.org/js/telegram-web-app.js&quot;&gt;&lt;/script&gt;&#10;&#10;    &lt;title&gt;Gift Propaganda News&lt;/title&gt;&#10;&#10;    &lt;style&gt;&#10;      html, body {&#10;        margin: 0;&#10;        padding: 0;&#10;        height: 100%;&#10;        overflow-x: hidden;&#10;      }&#10;&#10;      body {&#10;        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',&#10;          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',&#10;          sans-serif;&#10;        -webkit-font-smoothing: antialiased;&#10;        -moz-osx-font-smoothing: grayscale;&#10;        background-color: var(--tg-theme-bg-color, #ffffff);&#10;        color: var(--tg-theme-text-color, #000000);&#10;      }&#10;&#10;      #root {&#10;        height: 100%;&#10;      }&#10;&#10;      /* Telegram Web App specific styles */&#10;      .twa-viewport {&#10;        height: 100vh;&#10;        height: var(--tg-viewport-height, 100vh);&#10;      }&#10;    &lt;/style&gt;&#10;  &lt;/head&gt;&#10;  &lt;body&gt;&#10;    &lt;noscript&gt;Вам необходимо включить JavaScript для работы этого приложения.&lt;/noscript&gt;&#10;    &lt;div id=&quot;root&quot; class=&quot;twa-viewport&quot;&gt;&lt;/div&gt;&#10;&#10;    &lt;script&gt;&#10;      // Инициализация Telegram Web App&#10;      if (window.Telegram &amp;&amp; window.Telegram.WebApp) {&#10;        window.Telegram.WebApp.ready();&#10;        window.Telegram.WebApp.expand();&#10;&#10;        // Применяем CSS переменные Telegram&#10;        const root = document.documentElement;&#10;        const tgWebApp = window.Telegram.WebApp;&#10;&#10;        if (tgWebApp.themeParams) {&#10;          Object.keys(tgWebApp.themeParams).forEach(key =&gt; {&#10;            root.style.setProperty(`--tg-theme-${key.replace(/_/g, '-')}`, tgWebApp.themeParams[key]);&#10;          });&#10;        }&#10;&#10;        // Устанавливаем высоту viewport&#10;        if (tgWebApp.viewportHeight) {&#10;          root.style.setProperty('--tg-viewport-height', `${tgWebApp.viewportHeight}px`);&#10;        }&#10;      }&#10;    &lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;&#10;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;ru&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;utf-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no&quot; /&gt;&#10;    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;&#10;    &lt;meta name=&quot;description&quot; content=&quot;Gift Propaganda News - новости о подарках, криптовалютах и NFT в Telegram&quot; /&gt;&#10;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;&#10;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;&#10;&#10;    &lt;!-- Telegram Web App SDK --&gt;&#10;    &lt;script src=&quot;https://telegram.org/js/telegram-web-app.js&quot;&gt;&lt;/script&gt;&#10;&#10;    &lt;title&gt; Gift Propaganda News&lt;/title&gt;&#10;&#10;    &lt;style&gt;&#10;      /* CSS переменные для Telegram Web App */&#10;      :root {&#10;        --tg-theme-bg-color: #ffffff;&#10;        --tg-theme-text-color: #000000;&#10;        --tg-theme-hint-color: #8e8e93;&#10;        --tg-theme-link-color: #007aff;&#10;        --tg-theme-button-color: #007aff;&#10;        --tg-theme-button-text-color: #ffffff;&#10;        --tg-theme-secondary-bg-color: #f8f9fa;&#10;        --tg-theme-destructive-text-color: #ff3b30;&#10;        --tg-viewport-height: 100vh;&#10;      }&#10;&#10;      /* Темная тема для Telegram */&#10;      @media (prefers-color-scheme: dark) {&#10;        :root {&#10;          --tg-theme-bg-color: #212121;&#10;          --tg-theme-text-color: #ffffff;&#10;          --tg-theme-hint-color: #8e8e93;&#10;          --tg-theme-link-color: #6ab7ff;&#10;          --tg-theme-button-color: #5288c1;&#10;          --tg-theme-button-text-color: #ffffff;&#10;          --tg-theme-secondary-bg-color: #181818;&#10;          --tg-theme-destructive-text-color: #ff453a;&#10;        }&#10;      }&#10;&#10;      html, body {&#10;        margin: 0;&#10;        padding: 0;&#10;        height: var(--tg-viewport-height, 100vh);&#10;        overflow-x: hidden;&#10;      }&#10;&#10;      body {&#10;        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',&#10;          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',&#10;          sans-serif;&#10;        -webkit-font-smoothing: antialiased;&#10;        -moz-osx-font-smoothing: grayscale;&#10;        background-color: var(--tg-theme-bg-color);&#10;        color: var(--tg-theme-text-color);&#10;      }&#10;&#10;      #root {&#10;        height: 100%;&#10;      }&#10;&#10;      /* Убираем выделение текста */&#10;      * {&#10;        -webkit-touch-callout: none;&#10;        -webkit-user-select: none;&#10;        -khtml-user-select: none;&#10;        -moz-user-select: none;&#10;        -ms-user-select: none;&#10;        user-select: none;&#10;      }&#10;&#10;      /* Разрешаем выделение для текста новостей */&#10;      p, span, div[class*=&quot;NewsText&quot;], div[class*=&quot;NewsContent&quot;] {&#10;        -webkit-user-select: text;&#10;        -moz-user-select: text;&#10;        -ms-user-select: text;&#10;        user-select: text;&#10;      }&#10;    &lt;/style&gt;&#10;  &lt;/head&gt;&#10;  &lt;body&gt;&#10;    &lt;noscript&gt;Для работы приложения необходимо включить JavaScript.&lt;/noscript&gt;&#10;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#10;    &#10;    &lt;script&gt;&#10;      // Инициализация Telegram Web App&#10;      if (window.Telegram &amp;&amp; window.Telegram.WebApp) {&#10;        window.Telegram.WebApp.ready();&#10;        window.Telegram.WebApp.expand();&#10;        &#10;        // Устанавливаем CSS переменные из темы Telegram&#10;        const themeParams = window.Telegram.WebApp.themeParams;&#10;        if (themeParams) {&#10;          const root = document.documentElement;&#10;          Object.entries(themeParams).forEach(([key, value]) =&gt; {&#10;            root.style.setProperty(`--tg-theme-${key.replace(/_/g, '-')}`, value);&#10;          });&#10;        }&#10;        &#10;        // Устанавливаем высоту viewport&#10;        const setViewportHeight = () =&gt; {&#10;          const vh = window.Telegram.WebApp.viewportHeight || window.innerHeight;&#10;          document.documentElement.style.setProperty('--tg-viewport-height', `${vh}px`);&#10;        };&#10;        &#10;        setViewportHeight();&#10;        window.Telegram.WebApp.onEvent('viewportChanged', setViewportHeight);&#10;        &#10;        // Слушаем изменения темы&#10;        window.Telegram.WebApp.onEvent('themeChanged', () =&gt; {&#10;          const themeParams = window.Telegram.WebApp.themeParams;&#10;          if (themeParams) {&#10;            const root = document.documentElement;&#10;            Object.entries(themeParams).forEach(([key, value]) =&gt; {&#10;              root.style.setProperty(`--tg-theme-${key.replace(/_/g, '-')}`, value);&#10;            });&#10;          }&#10;          // Отправляем кастомное событие для React&#10;          window.dispatchEvent(new CustomEvent('themeChanged'));&#10;        });&#10;      }&#10;    &lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useCallback } from 'react';&#10;import styled, { ThemeProvider, createGlobalStyle } from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;import TelegramWebApp from './telegram/TelegramWebApp';&#10;import SearchBar from './components/SearchBar';&#10;import NewsModal from './components/NewsModal';&#10;&#10;// Глобальные стили для Telegram Mini App&#10;const GlobalStyle = createGlobalStyle&lt;{ theme: any }&gt;`&#10;  * {&#10;    margin: 0;&#10;    padding: 0;&#10;    box-sizing: border-box;&#10;  }&#10;&#10;  body {&#10;    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;&#10;    background-color: var(--tg-theme-bg-color, #ffffff);&#10;    color: var(--tg-theme-text-color, #000000);&#10;    overflow-x: hidden;&#10;    -webkit-font-smoothing: antialiased;&#10;    -moz-osx-font-smoothing: grayscale;&#10;    margin: 0;&#10;    padding: 0;&#10;  }&#10;&#10;  html, body, #root {&#10;    height: var(--tg-viewport-height, 100vh);&#10;    margin: 0;&#10;    padding: 0;&#10;  }&#10;`;&#10;&#10;const AppContainer = styled.div&lt;{ theme: any }&gt;`&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  min-height: var(--tg-viewport-height, 100vh);&#10;  color: var(--tg-theme-text-color, #000000);&#10;  padding: 0;&#10;  margin: 0;&#10;`;&#10;&#10;const Header = styled.header&lt;{ theme: any }&gt;`&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;  color: var(--tg-theme-text-color, #000000);&#10;  padding: 16px;&#10;  text-align: center;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;`;&#10;&#10;const Title = styled.h1`&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  margin: 0;&#10;  color: var(--tg-theme-text-color, #000000);&#10;`;&#10;&#10;const CategoryFilter = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  padding: 12px 16px;&#10;  overflow-x: auto;&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;`;&#10;&#10;const CategoryButton = styled.button&lt;{ active: boolean }&gt;`&#10;  padding: 8px 16px;&#10;  border-radius: 20px;&#10;  border: 1px solid var(--tg-theme-button-color, #007AFF);&#10;  background-color: ${props =&gt; props.active ? 'var(--tg-theme-button-color, #007AFF)' : 'transparent'};&#10;  color: ${props =&gt; props.active ? 'var(--tg-theme-button-text-color, #ffffff)' : 'var(--tg-theme-button-color, #007AFF)'};&#10;  font-size: 14px;&#10;  white-space: nowrap;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const NewsList = styled.div`&#10;  padding: 8px;&#10;`;&#10;&#10;const NewsItemCard = styled.div&lt;{ isNew?: boolean }&gt;`&#10;  background-color: var(--tg-theme-secondary-bg-color, #ffffff);&#10;  margin-bottom: 8px;&#10;  border-radius: 12px;&#10;  overflow: hidden;&#10;  border: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  transition: transform 0.1s ease;&#10;  position: relative;&#10;  cursor: pointer;&#10;&#10;  ${props =&gt; props.isNew &amp;&amp; `&#10;    border-left: 4px solid var(--tg-theme-button-color, #007AFF);&#10;    box-shadow: 0 2px 8px rgba(0, 122, 255, 0.1);&#10;  `}&#10;&#10;  &amp;:active {&#10;    transform: scale(0.98);&#10;  }&#10;`;&#10;&#10;const NewsContent = styled.div`&#10;  padding: 16px;&#10;`;&#10;&#10;const NewsTitle = styled.h2`&#10;  color: var(--tg-theme-link-color, #007AFF);&#10;  margin: 0 0 8px 0;&#10;  font-size: 16px;&#10;  font-weight: 600;&#10;  line-height: 1.3;&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 2;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsText = styled.p`&#10;  color: var(--tg-theme-text-color, #000000);&#10;  margin: 0 0 12px 0;&#10;  font-size: 14px;&#10;  line-height: 1.4;&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 3;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsFooter = styled.div`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  margin-top: 8px;&#10;`;&#10;&#10;const NewsSource = styled.span`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 12px;&#10;`;&#10;&#10;const NewsDate = styled.span`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 12px;&#10;`;&#10;&#10;const CategoryTag = styled.span&lt;{ category: string }&gt;`&#10;  background-color: ${props =&gt; getCategoryColor(props.category)};&#10;  color: white;&#10;  padding: 2px 8px;&#10;  border-radius: 12px;&#10;  font-size: 10px;&#10;  font-weight: 500;&#10;  text-transform: uppercase;&#10;`;&#10;&#10;const LoadingContainer = styled.div`&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  height: 200px;&#10;  color: var(--tg-theme-hint-color, #999999);&#10;`;&#10;&#10;const ErrorContainer = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  height: 200px;&#10;  color: var(--tg-theme-destructive-text-color, #ff3b30);&#10;  text-align: center;&#10;  padding: 20px;&#10;`;&#10;&#10;const RetryButton = styled.button`&#10;  background-color: var(--tg-theme-button-color, #007AFF);&#10;  color: var(--tg-theme-button-text-color, #ffffff);&#10;  border: none;&#10;  padding: 12px 24px;&#10;  border-radius: 8px;&#10;  margin-top: 16px;&#10;  cursor: pointer;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;const getCategoryColor = (category: string): string =&gt; {&#10;  const colors: { [key: string]: string } = {&#10;    gifts: '#FF6B6B',&#10;    crypto: '#4ECDC4',&#10;    nft: '#45B7D1',&#10;    tech: '#96CEB4',&#10;    community: '#FECA57',&#10;    general: '#DDA0DD'&#10;  };&#10;  return colors[category] || colors.general;&#10;};&#10;&#10;// Функция для форматирования даты&#10;const formatDate = (dateString: string): string =&gt; {&#10;  const date = new Date(dateString);&#10;  const now = new Date();&#10;  const diffMs = now.getTime() - date.getTime();&#10;  const diffMins = Math.floor(diffMs / 60000);&#10;  const diffHours = Math.floor(diffMins / 60);&#10;  const diffDays = Math.floor(diffHours / 24);&#10;&#10;  if (diffMins &lt; 1) return 'сейчас';&#10;  if (diffMins &lt; 60) return `${diffMins}м`;&#10;  if (diffHours &lt; 24) return `${diffHours}ч`;&#10;  if (diffDays &lt; 7) return `${diffDays}д`;&#10;&#10;  return date.toLocaleDateString('ru-RU', {&#10;    day: 'numeric',&#10;    month: 'short'&#10;  });&#10;};&#10;&#10;const categories = [&#10;  { key: 'all', label: 'Все' },&#10;  { key: 'gifts', label: 'Подарки' },&#10;  { key: 'crypto', label: 'Крипто' },&#10;  { key: 'nft', label: 'NFT' },&#10;  { key: 'tech', label: 'Технологии' },&#10;  { key: 'community', label: 'Сообщество' }&#10;];&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsItem[]&gt;([]);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [searchTerm, setSearchTerm] = useState&lt;string&gt;('');&#10;  const [selectedCategory, setSelectedCategory] = useState&lt;string&gt;('all');&#10;  const [selectedNews, setSelectedNews] = useState&lt;NewsItem | null&gt;(null);&#10;  const [theme, setTheme] = useState&lt;any&gt;({});&#10;&#10;  // Инициализация Telegram WebApp&#10;  useEffect(() =&gt; {&#10;    TelegramWebApp.init();&#10;    setTheme(TelegramWebApp.getThemeParams());&#10;&#10;    // Слушаем изменения темы&#10;    const handleThemeChanged = () =&gt; {&#10;      setTheme(TelegramWebApp.getThemeParams());&#10;    };&#10;&#10;    window.addEventListener('themeChanged', handleThemeChanged);&#10;    return () =&gt; window.removeEventListener('themeChanged', handleThemeChanged);&#10;  }, []);&#10;&#10;  // Загрузка новостей&#10;  const getNews = useCallback(async () =&gt; {&#10;    setLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      const response: NewsResponse = await fetchNews(selectedCategory === 'all' ? undefined : selectedCategory);&#10;&#10;      if (response.status === 'success') {&#10;        setNews(response.data);&#10;      } else {&#10;        setError(response.message || 'Ошибка загрузки новостей');&#10;      }&#10;    } catch (err) {&#10;      setError('Ошибка сети');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  }, [selectedCategory]);&#10;&#10;  useEffect(() =&gt; {&#10;    getNews();&#10;  }, [getNews]);&#10;&#10;  // Фильтрация новостей по поиску&#10;  const filteredNews = news.filter(item =&gt;&#10;    item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;    item.content.toLowerCase().includes(searchTerm.toLowerCase())&#10;  );&#10;&#10;  const handleNewsClick = (newsItem: NewsItem) =&gt; {&#10;    setSelectedNews(newsItem);&#10;    TelegramWebApp.triggerHapticFeedback('light');&#10;  };&#10;&#10;  const handleCategoryChange = (category: string) =&gt; {&#10;    setSelectedCategory(category);&#10;    TelegramWebApp.triggerHapticFeedback('selection_change');&#10;  };&#10;&#10;  return (&#10;    &lt;ThemeProvider theme={theme}&gt;&#10;      &lt;GlobalStyle theme={theme} /&gt;&#10;      &lt;AppContainer theme={theme}&gt;&#10;        &lt;Header theme={theme}&gt;&#10;          &lt;Title&gt; Gift Propaganda News&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;&#10;        &lt;SearchBar&#10;          value={searchTerm}&#10;          onChange={setSearchTerm}&#10;          placeholder=&quot;Поиск новостей...&quot;&#10;        /&gt;&#10;&#10;        &lt;CategoryFilter&gt;&#10;          {categories.map(category =&gt; (&#10;            &lt;CategoryButton&#10;              key={category.key}&#10;              active={selectedCategory === category.key}&#10;              onClick={() =&gt; handleCategoryChange(category.key)}&#10;            &gt;&#10;              {category.label}&#10;            &lt;/CategoryButton&gt;&#10;          ))}&#10;        &lt;/CategoryFilter&gt;&#10;&#10;        {loading &amp;&amp; (&#10;          &lt;LoadingContainer&gt;&#10;            Загрузка новостей...&#10;          &lt;/LoadingContainer&gt;&#10;        )}&#10;&#10;        {error &amp;&amp; (&#10;          &lt;ErrorContainer&gt;&#10;            &lt;div&gt;{error}&lt;/div&gt;&#10;            &lt;RetryButton onClick={getNews}&gt;&#10;              Повторить&#10;            &lt;/RetryButton&gt;&#10;          &lt;/ErrorContainer&gt;&#10;        )}&#10;&#10;        {!loading &amp;&amp; !error &amp;&amp; (&#10;          &lt;NewsList&gt;&#10;            {filteredNews.length === 0 ? (&#10;              &lt;div style={{ textAlign: 'center', padding: '40px 20px', color: 'var(--tg-theme-hint-color, #999999)' }}&gt;&#10;                Новостей не найдено&#10;              &lt;/div&gt;&#10;            ) : (&#10;              filteredNews.map((item) =&gt; (&#10;                &lt;NewsItemCard&#10;                  key={item.id}&#10;                  onClick={() =&gt; handleNewsClick(item)}&#10;                  isNew={new Date(item.publish_date) &gt; new Date(Date.now() - 24 * 60 * 60 * 1000)}&#10;                &gt;&#10;                  &lt;NewsContent&gt;&#10;                    &lt;NewsTitle&gt;{item.title}&lt;/NewsTitle&gt;&#10;                    &lt;NewsText&gt;{item.content}&lt;/NewsText&gt;&#10;                    &lt;NewsFooter&gt;&#10;                      &lt;div&gt;&#10;                        &lt;CategoryTag category={item.category}&gt;&#10;                          {categories.find(c =&gt; c.key === item.category)?.label || item.category}&#10;                        &lt;/CategoryTag&gt;&#10;                        &lt;NewsSource style={{ marginLeft: '8px' }}&gt;&#10;                          {item.source?.name || 'Telegram'}&#10;                        &lt;/NewsSource&gt;&#10;                      &lt;/div&gt;&#10;                      &lt;NewsDate&gt;&#10;                        {formatDate(item.publish_date)}&#10;                      &lt;/NewsDate&gt;&#10;                    &lt;/NewsFooter&gt;&#10;                  &lt;/NewsContent&gt;&#10;                &lt;/NewsItemCard&gt;&#10;              ))&#10;            )}&#10;          &lt;/NewsList&gt;&#10;        )}&#10;&#10;        {selectedNews &amp;&amp; (&#10;          &lt;NewsModal&#10;            news={selectedNews}&#10;            onClose={() =&gt; setSelectedNews(null)}&#10;          /&gt;&#10;        )}&#10;      &lt;/AppContainer&gt;&#10;    &lt;/ThemeProvider&gt;&#10;  );&#10;};&#10;&#10;export default App;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useCallback } from 'react';&#10;import styled, { ThemeProvider, createGlobalStyle } from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;import TelegramWebApp from './telegram/TelegramWebApp';&#10;import SearchBar from './components/SearchBar';&#10;import NewsModal from './components/NewsModal';&#10;&#10;// Глобальные стили для Telegram Mini App&#10;const GlobalStyle = createGlobalStyle&lt;{ theme: any }&gt;`&#10;  * {&#10;    margin: 0;&#10;    padding: 0;&#10;    box-sizing: border-box;&#10;  }&#10;&#10;  body {&#10;    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;&#10;    background-color: var(--tg-theme-bg-color, #ffffff);&#10;    color: var(--tg-theme-text-color, #000000);&#10;    overflow-x: hidden;&#10;    -webkit-font-smoothing: antialiased;&#10;    -moz-osx-font-smoothing: grayscale;&#10;    margin: 0;&#10;    padding: 0;&#10;  }&#10;&#10;  html, body, #root {&#10;    height: var(--tg-viewport-height, 100vh);&#10;    margin: 0;&#10;    padding: 0;&#10;  }&#10;`;&#10;&#10;const AppContainer = styled.div&lt;{ theme: any }&gt;`&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  min-height: var(--tg-viewport-height, 100vh);&#10;  color: var(--tg-theme-text-color, #000000);&#10;  padding: 0;&#10;  margin: 0;&#10;`;&#10;&#10;const Header = styled.header&lt;{ theme: any }&gt;`&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;  color: var(--tg-theme-text-color, #000000);&#10;  padding: 16px;&#10;  text-align: center;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  position: sticky;&#10;  top: 0;&#10;  z-index: 100;&#10;`;&#10;&#10;const Title = styled.h1`&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  margin: 0;&#10;  color: var(--tg-theme-text-color, #000000);&#10;`;&#10;&#10;const CategoryFilter = styled.div`&#10;  display: flex;&#10;  gap: 8px;&#10;  padding: 12px 16px;&#10;  overflow-x: auto;&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;`;&#10;&#10;const CategoryButton = styled.button&lt;{ $active: boolean }&gt;`&#10;  padding: 8px 16px;&#10;  border-radius: 20px;&#10;  border: 1px solid var(--tg-theme-button-color, #007AFF);&#10;  background-color: ${props =&gt; props.$active ? 'var(--tg-theme-button-color, #007AFF)' : 'transparent'};&#10;  color: ${props =&gt; props.$active ? 'var(--tg-theme-button-text-color, #ffffff)' : 'var(--tg-theme-button-color, #007AFF)'};&#10;  font-size: 14px;&#10;  white-space: nowrap;&#10;  cursor: pointer;&#10;  transition: all 0.2s ease;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const NewsList = styled.div`&#10;  padding: 8px;&#10;`;&#10;&#10;const NewsItemCard = styled.div&lt;{ $isNew?: boolean }&gt;`&#10;  background-color: var(--tg-theme-secondary-bg-color, #ffffff);&#10;  margin-bottom: 8px;&#10;  border-radius: 12px;&#10;  overflow: hidden;&#10;  border: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  transition: transform 0.1s ease;&#10;  position: relative;&#10;  cursor: pointer;&#10;&#10;  ${props =&gt; props.$isNew &amp;&amp; `&#10;    border-left: 4px solid var(--tg-theme-button-color, #007AFF);&#10;    box-shadow: 0 2px 8px rgba(0, 122, 255, 0.1);&#10;  `}&#10;&#10;  &amp;:active {&#10;    transform: scale(0.98);&#10;  }&#10;`;&#10;&#10;const NewsContent = styled.div`&#10;  padding: 16px;&#10;`;&#10;&#10;const NewsTitle = styled.h2`&#10;  color: var(--tg-theme-link-color, #007AFF);&#10;  margin: 0 0 8px 0;&#10;  font-size: 16px;&#10;  font-weight: 600;&#10;  line-height: 1.3;&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 2;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsText = styled.p`&#10;  color: var(--tg-theme-text-color, #000000);&#10;  margin: 0 0 12px 0;&#10;  font-size: 14px;&#10;  line-height: 1.4;&#10;  display: -webkit-box;&#10;  -webkit-line-clamp: 3;&#10;  -webkit-box-orient: vertical;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsFooter = styled.div`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  margin-top: 8px;&#10;`;&#10;&#10;const NewsSource = styled.span`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 12px;&#10;`;&#10;&#10;const NewsDate = styled.span`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 12px;&#10;`;&#10;&#10;const CategoryTag = styled.span&lt;{ $category: string }&gt;`&#10;  background-color: ${props =&gt; getCategoryColor(props.$category)};&#10;  color: white;&#10;  padding: 2px 8px;&#10;  border-radius: 12px;&#10;  font-size: 10px;&#10;  font-weight: 500;&#10;  text-transform: uppercase;&#10;`;&#10;&#10;const LoadingContainer = styled.div`&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  height: 200px;&#10;  color: var(--tg-theme-hint-color, #999999);&#10;`;&#10;&#10;const ErrorContainer = styled.div`&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  height: 200px;&#10;  color: var(--tg-theme-destructive-text-color, #ff3b30);&#10;  text-align: center;&#10;  padding: 20px;&#10;`;&#10;&#10;const RetryButton = styled.button`&#10;  background-color: var(--tg-theme-button-color, #007AFF);&#10;  color: var(--tg-theme-button-text-color, #ffffff);&#10;  border: none;&#10;  padding: 12px 24px;&#10;  border-radius: 8px;&#10;  margin-top: 16px;&#10;  cursor: pointer;&#10;&#10;  &amp;:active {&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;// Компоненты для медиа&#10;const MediaContainer = styled.div`&#10;  margin: 12px 0;&#10;  border-radius: 8px;&#10;  overflow: hidden;&#10;`;&#10;&#10;const NewsImage = styled.img`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 300px;&#10;  object-fit: cover;&#10;  border-radius: 8px;&#10;`;&#10;&#10;const NewsVideo = styled.video`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 300px;&#10;  border-radius: 8px;&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;const getCategoryColor = (category: string): string =&gt; {&#10;  const colors: { [key: string]: string } = {&#10;    gifts: '#FF6B6B',&#10;    crypto: '#4ECDC4',&#10;    nft: '#45B7D1',&#10;    tech: '#96CEB4',&#10;    community: '#FECA57',&#10;    general: '#DDA0DD'&#10;  };&#10;  return colors[category] || colors.general;&#10;};&#10;&#10;// Функция для форматирования даты&#10;const formatDate = (dateString: string): string =&gt; {&#10;  const date = new Date(dateString);&#10;  const now = new Date();&#10;  const diffMs = now.getTime() - date.getTime();&#10;  const diffMins = Math.floor(diffMs / 60000);&#10;  const diffHours = Math.floor(diffMins / 60);&#10;  const diffDays = Math.floor(diffHours / 24);&#10;&#10;  if (diffMins &lt; 1) return 'сейчас';&#10;  if (diffMins &lt; 60) return `${diffMins}м`;&#10;  if (diffHours &lt; 24) return `${diffHours}ч`;&#10;  if (diffDays &lt; 7) return `${diffDays}д`;&#10;&#10;  return date.toLocaleDateString('ru-RU', {&#10;    day: 'numeric',&#10;    month: 'short'&#10;  });&#10;};&#10;&#10;const categories = [&#10;  { key: 'all', label: 'Все' },&#10;  { key: 'gifts', label: 'Подарки' },&#10;  { key: 'crypto', label: 'Крипто' },&#10;  { key: 'nft', label: 'NFT' },&#10;  { key: 'tech', label: 'Технологии' },&#10;  { key: 'community', label: 'Сообщество' }&#10;];&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsItem[]&gt;([]);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(true);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [searchTerm, setSearchTerm] = useState&lt;string&gt;('');&#10;  const [selectedCategory, setSelectedCategory] = useState&lt;string&gt;('all');&#10;  const [selectedNews, setSelectedNews] = useState&lt;NewsItem | null&gt;(null);&#10;  const [theme, setTheme] = useState&lt;any&gt;({});&#10;&#10;  // Инициализация Telegram WebApp&#10;  useEffect(() =&gt; {&#10;    TelegramWebApp.init();&#10;    setTheme(TelegramWebApp.getThemeParams());&#10;&#10;    // Слушаем изменения темы&#10;    const handleThemeChanged = () =&gt; {&#10;      setTheme(TelegramWebApp.getThemeParams());&#10;    };&#10;&#10;    window.addEventListener('themeChanged', handleThemeChanged);&#10;    return () =&gt; window.removeEventListener('themeChanged', handleThemeChanged);&#10;  }, []);&#10;&#10;  // Загрузка новостей&#10;  const getNews = useCallback(async () =&gt; {&#10;    setLoading(true);&#10;    setError(null);&#10;&#10;    try {&#10;      const response: NewsResponse = await fetchNews(selectedCategory === 'all' ? undefined : selectedCategory);&#10;&#10;      if (response.status === 'success') {&#10;        setNews(response.data);&#10;      } else {&#10;        setError(response.message || 'Ошибка загрузки новостей');&#10;      }&#10;    } catch (err) {&#10;      setError('Ошибка сети');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  }, [selectedCategory]);&#10;&#10;  useEffect(() =&gt; {&#10;    getNews();&#10;  }, [getNews]);&#10;&#10;  // Фильтрация новостей по поиску&#10;  const filteredNews = news.filter(item =&gt;&#10;    item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;    item.content.toLowerCase().includes(searchTerm.toLowerCase())&#10;  );&#10;&#10;  const handleNewsClick = (newsItem: NewsItem) =&gt; {&#10;    setSelectedNews(newsItem);&#10;    TelegramWebApp.triggerHapticFeedback('light');&#10;  };&#10;&#10;  const handleCategoryChange = (category: string) =&gt; {&#10;    setSelectedCategory(category);&#10;    TelegramWebApp.triggerHapticFeedback('selection_change');&#10;  };&#10;&#10;  return (&#10;    &lt;ThemeProvider theme={theme}&gt;&#10;      &lt;GlobalStyle theme={theme} /&gt;&#10;      &lt;AppContainer theme={theme}&gt;&#10;        &lt;Header theme={theme}&gt;&#10;          &lt;Title&gt; Gift Propaganda News&lt;/Title&gt;&#10;        &lt;/Header&gt;&#10;&#10;        &lt;SearchBar&#10;          value={searchTerm}&#10;          onChange={setSearchTerm}&#10;          placeholder=&quot;Поиск новостей...&quot;&#10;        /&gt;&#10;&#10;        &lt;CategoryFilter&gt;&#10;          {categories.map(category =&gt; (&#10;            &lt;CategoryButton&#10;              key={category.key}&#10;              $active={selectedCategory === category.key}&#10;              onClick={() =&gt; handleCategoryChange(category.key)}&#10;            &gt;&#10;              {category.label}&#10;            &lt;/CategoryButton&gt;&#10;          ))}&#10;        &lt;/CategoryFilter&gt;&#10;&#10;        {loading &amp;&amp; (&#10;          &lt;LoadingContainer&gt;&#10;            Загрузка новостей...&#10;          &lt;/LoadingContainer&gt;&#10;        )}&#10;&#10;        {error &amp;&amp; (&#10;          &lt;ErrorContainer&gt;&#10;            &lt;div&gt;{error}&lt;/div&gt;&#10;            &lt;RetryButton onClick={getNews}&gt;&#10;              Повторить&#10;            &lt;/RetryButton&gt;&#10;          &lt;/ErrorContainer&gt;&#10;        )}&#10;&#10;        {!loading &amp;&amp; !error &amp;&amp; (&#10;          &lt;NewsList&gt;&#10;            {filteredNews.length === 0 ? (&#10;              &lt;div style={{ textAlign: 'center', padding: '40px 20px', color: 'var(--tg-theme-hint-color, #999999)' }}&gt;&#10;                Новостей не найдено&#10;              &lt;/div&gt;&#10;            ) : (&#10;              filteredNews.map((item) =&gt; (&#10;                &lt;NewsItemCard&#10;                  key={item.id}&#10;                  onClick={() =&gt; handleNewsClick(item)}&#10;                  $isNew={new Date(item.publish_date) &gt; new Date(Date.now() - 24 * 60 * 60 * 1000)}&#10;                &gt;&#10;                  &lt;NewsContent&gt;&#10;                    &lt;NewsTitle&gt;{item.title}&lt;/NewsTitle&gt;&#10;                    &#10;                    {/* Добавляем поддержку медиа */}&#10;                    {item.media &amp;&amp; (&#10;                      &lt;MediaContainer&gt;&#10;                        {item.media.type === 'photo' &amp;&amp; (&#10;                          &lt;NewsImage &#10;                            src={item.media.url} &#10;                            alt={item.title}&#10;                            loading=&quot;lazy&quot;&#10;                          /&gt;&#10;                        )}&#10;                        {item.media.type === 'video' &amp;&amp; (&#10;                          &lt;NewsVideo &#10;                            src={item.media.url}&#10;                            controls&#10;                            preload=&quot;metadata&quot;&#10;                          /&gt;&#10;                        )}&#10;                      &lt;/MediaContainer&gt;&#10;                    )}&#10;                    &#10;                    &lt;NewsText&gt;{item.content}&lt;/NewsText&gt;&#10;                    &lt;NewsFooter&gt;&#10;                      &lt;div&gt;&#10;                        &lt;CategoryTag $category={item.category}&gt;&#10;                          {categories.find(c =&gt; c.key === item.category)?.label || item.category}&#10;                        &lt;/CategoryTag&gt;&#10;                        &lt;NewsSource style={{ marginLeft: '8px' }}&gt;&#10;                          {item.source?.name || 'Telegram'}&#10;                        &lt;/NewsSource&gt;&#10;                      &lt;/div&gt;&#10;                      &lt;NewsDate&gt;&#10;                        {formatDate(item.publish_date)}&#10;                      &lt;/NewsDate&gt;&#10;                    &lt;/NewsFooter&gt;&#10;                  &lt;/NewsContent&gt;&#10;                &lt;/NewsItemCard&gt;&#10;              ))&#10;            )}&#10;          &lt;/NewsList&gt;&#10;        )}&#10;&#10;        {selectedNews &amp;&amp; (&#10;          &lt;NewsModal&#10;            news={selectedNews}&#10;            onClose={() =&gt; setSelectedNews(null)}&#10;          /&gt;&#10;        )}&#10;      &lt;/AppContainer&gt;&#10;    &lt;/ThemeProvider&gt;&#10;  );&#10;};&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  source?: {&#10;    name: string;&#10;    type: string;&#10;  };&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000 // 10 секунд таймаут&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;&#10;    // Возвращаем более детальную информацию об ошибке&#10;    let errorMessage = 'Ошибка загрузки новостей';&#10;    if (error.response) {&#10;      errorMessage = `Ошибка сервера: ${error.response.status}`;&#10;    } else if (error.request) {&#10;      errorMessage = 'Нет ответа от сервера';&#10;    }&#10;&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: errorMessage&#10;    };&#10;  }&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface MediaItem {&#10;  type: 'photo' | 'video';&#10;  url: string;&#10;  thumbnail?: string;&#10;  width?: number;&#10;  height?: number;&#10;}&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  media?: MediaItem; // Добавляем поддержку медиа&#10;  source?: {&#10;    name: string;&#10;    type: string;&#10;  };&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000 // 10 секунд таймаут&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;&#10;    // Возвращаем более детальную информацию об ошибке&#10;    let errorMessage = 'Ошибка загрузки новостей';&#10;    if (error.response) {&#10;      errorMessage = `Ошибка сервера: ${error.response.status}`;&#10;    } else if (error.request) {&#10;      errorMessage = 'Нет ответа от сервера';&#10;    }&#10;&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: errorMessage&#10;    };&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/components/NewsModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/components/NewsModal.tsx" />
              <option name="originalContent" value="import React, { useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { NewsItem } from '../api/news';&#10;import TelegramWebApp from '../telegram/TelegramWebApp';&#10;&#10;const ModalOverlay = styled.div&lt;{ isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  display: ${props =&gt; props.isOpen ? 'flex' : 'none'};&#10;  justify-content: center;&#10;  align-items: flex-end;&#10;  z-index: 1000;&#10;`;&#10;&#10;const ModalContent = styled.div&lt;{ isOpen: boolean }&gt;`&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  width: 100%;&#10;  max-height: 80vh;&#10;  border-radius: 16px 16px 0 0;&#10;  transform: ${props =&gt; props.isOpen ? 'translateY(0)' : 'translateY(100%)'};&#10;  transition: transform 0.3s ease-out;&#10;  overflow: hidden;&#10;  display: flex;&#10;  flex-direction: column;&#10;`;&#10;&#10;const ModalHeader = styled.div`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  padding: 16px 20px;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;`;&#10;&#10;const ModalTitle = styled.h3`&#10;  color: var(--tg-theme-text-color, #000000);&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  margin: 0;&#10;  flex: 1;&#10;  line-height: 1.3;&#10;`;&#10;&#10;const CloseButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  font-size: 24px;&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  cursor: pointer;&#10;  padding: 4px;&#10;  margin-left: 12px;&#10;  border-radius: 50%;&#10;  width: 32px;&#10;  height: 32px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  &#10;  &amp;:active {&#10;    background-color: var(--tg-theme-hint-color, #e0e0e0);&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const ModalBody = styled.div`&#10;  flex: 1;&#10;  overflow-y: auto;&#10;  padding: 20px;&#10;`;&#10;&#10;const NewsContent = styled.div`&#10;  line-height: 1.6;&#10;  color: var(--tg-theme-text-color, #000000);&#10;  font-size: 16px;&#10;  white-space: pre-wrap;&#10;  word-wrap: break-word;&#10;`;&#10;&#10;const NewsFooter = styled.div`&#10;  padding: 16px 20px;&#10;  border-top: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;`;&#10;&#10;const NewsSource = styled.div`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 14px;&#10;`;&#10;&#10;const NewsDate = styled.div`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 14px;&#10;`;&#10;&#10;const CategoryTag = styled.span&lt;{ category: string }&gt;`&#10;  background-color: ${props =&gt; getCategoryColor(props.category)};&#10;  color: white;&#10;  padding: 4px 12px;&#10;  border-radius: 16px;&#10;  font-size: 12px;&#10;  font-weight: 500;&#10;  text-transform: uppercase;&#10;  margin-bottom: 12px;&#10;  display: inline-block;&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;const getCategoryColor = (category: string): string =&gt; {&#10;  const colors: { [key: string]: string } = {&#10;    gifts: '#FF6B6B',&#10;    crypto: '#4ECDC4',&#10;    nft: '#45B7D1',&#10;    tech: '#96CEB4',&#10;    community: '#FECA57',&#10;    general: '#DDA0DD'&#10;  };&#10;  return colors[category] || colors.general;&#10;};&#10;&#10;// Функция для форматирования даты&#10;const formatFullDate = (dateString: string): string =&gt; {&#10;  const date = new Date(dateString);&#10;  return date.toLocaleDateString('ru-RU', {&#10;    year: 'numeric',&#10;    month: 'long',&#10;    day: 'numeric',&#10;    hour: '2-digit',&#10;    minute: '2-digit'&#10;  });&#10;};&#10;&#10;interface NewsModalProps {&#10;  news: NewsItem | null;&#10;  onClose: () =&gt; void;&#10;}&#10;&#10;const NewsModal: React.FC&lt;NewsModalProps&gt; = ({ news, onClose }) =&gt; {&#10;  const isOpen = !!news;&#10;&#10;  useEffect(() =&gt; {&#10;    if (isOpen) {&#10;      // Блокируем скролл основной страницы&#10;      document.body.style.overflow = 'hidden';&#10;      TelegramWebApp.triggerHapticFeedback('medium');&#10;    } else {&#10;      document.body.style.overflow = 'unset';&#10;    }&#10;&#10;    return () =&gt; {&#10;      document.body.style.overflow = 'unset';&#10;    };&#10;  }, [isOpen]);&#10;&#10;  const handleOverlayClick = (e: React.MouseEvent) =&gt; {&#10;    if (e.target === e.currentTarget) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('light');&#10;    onClose();&#10;  };&#10;&#10;  if (!news) return null;&#10;&#10;  return (&#10;    &lt;ModalOverlay isOpen={isOpen} onClick={handleOverlayClick}&gt;&#10;      &lt;ModalContent isOpen={isOpen}&gt;&#10;        &lt;ModalHeader&gt;&#10;          &lt;ModalTitle&gt;{news.title}&lt;/ModalTitle&gt;&#10;          &lt;CloseButton onClick={handleClose}&gt;×&lt;/CloseButton&gt;&#10;        &lt;/ModalHeader&gt;&#10;&#10;        &lt;ModalBody&gt;&#10;          &lt;CategoryTag category={news.category}&gt;&#10;            {news.category}&#10;          &lt;/CategoryTag&gt;&#10;          &lt;NewsContent&gt;{news.content}&lt;/NewsContent&gt;&#10;        &lt;/ModalBody&gt;&#10;&#10;        &lt;NewsFooter&gt;&#10;          &lt;NewsSource&gt;&#10;            Источник: {news.source?.name || 'Telegram'}&#10;          &lt;/NewsSource&gt;&#10;          &lt;NewsDate&gt;&#10;            {formatFullDate(news.publish_date)}&#10;          &lt;/NewsDate&gt;&#10;        &lt;/NewsFooter&gt;&#10;      &lt;/ModalContent&gt;&#10;    &lt;/ModalOverlay&gt;&#10;  );&#10;};&#10;&#10;export default NewsModal;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { NewsItem } from '../api/news';&#10;import TelegramWebApp from '../telegram/TelegramWebApp';&#10;&#10;const ModalOverlay = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  display: ${props =&gt; props.$isOpen ? 'flex' : 'none'};&#10;  justify-content: center;&#10;  align-items: flex-end;&#10;  z-index: 1000;&#10;`;&#10;&#10;const ModalContent = styled.div&lt;{ $isOpen: boolean }&gt;`&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  width: 100%;&#10;  max-height: 80vh;&#10;  border-radius: 16px 16px 0 0;&#10;  transform: ${props =&gt; props.$isOpen ? 'translateY(0)' : 'translateY(100%)'};&#10;  transition: transform 0.3s ease-out;&#10;  overflow: hidden;&#10;  display: flex;&#10;  flex-direction: column;&#10;`;&#10;&#10;const ModalHeader = styled.div`&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;  padding: 16px 20px;&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;`;&#10;&#10;const ModalTitle = styled.h3`&#10;  color: var(--tg-theme-text-color, #000000);&#10;  font-size: 18px;&#10;  font-weight: 600;&#10;  margin: 0;&#10;  flex: 1;&#10;  line-height: 1.3;&#10;`;&#10;&#10;const CloseButton = styled.button`&#10;  background: none;&#10;  border: none;&#10;  font-size: 24px;&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  cursor: pointer;&#10;  padding: 4px;&#10;  margin-left: 12px;&#10;  border-radius: 50%;&#10;  width: 32px;&#10;  height: 32px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  &#10;  &amp;:active {&#10;    background-color: var(--tg-theme-hint-color, #e0e0e0);&#10;    transform: scale(0.95);&#10;  }&#10;`;&#10;&#10;const ModalBody = styled.div`&#10;  flex: 1;&#10;  overflow-y: auto;&#10;  padding: 20px;&#10;`;&#10;&#10;const CategoryTag = styled.span&lt;{ $category: string }&gt;`&#10;  background-color: ${props =&gt; getCategoryColor(props.$category)};&#10;  color: white;&#10;  padding: 4px 12px;&#10;  border-radius: 16px;&#10;  font-size: 12px;&#10;  font-weight: 500;&#10;  text-transform: uppercase;&#10;  margin-bottom: 16px;&#10;  display: inline-block;&#10;`;&#10;&#10;// Компоненты для медиа в модальном окне&#10;const ModalMediaContainer = styled.div`&#10;  margin: 16px 0;&#10;  border-radius: 12px;&#10;  overflow: hidden;&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;`;&#10;&#10;const ModalNewsImage = styled.img`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 60vh;&#10;  object-fit: contain;&#10;  display: block;&#10;`;&#10;&#10;const ModalNewsVideo = styled.video`&#10;  width: 100%;&#10;  height: auto;&#10;  max-height: 60vh;&#10;  display: block;&#10;`;&#10;&#10;const NewsContent = styled.div`&#10;  line-height: 1.6;&#10;  color: var(--tg-theme-text-color, #000000);&#10;  font-size: 16px;&#10;  white-space: pre-wrap;&#10;  word-wrap: break-word;&#10;`;&#10;&#10;const NewsFooter = styled.div`&#10;  padding: 16px 20px;&#10;  border-top: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;`;&#10;&#10;const NewsSource = styled.div`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 14px;&#10;`;&#10;&#10;const NewsDate = styled.div`&#10;  color: var(--tg-theme-hint-color, #999999);&#10;  font-size: 14px;&#10;`;&#10;&#10;// Функция для получения цвета категории&#10;const getCategoryColor = (category: string): string =&gt; {&#10;  const colors: { [key: string]: string } = {&#10;    gifts: '#FF6B6B',&#10;    crypto: '#4ECDC4',&#10;    nft: '#45B7D1',&#10;    tech: '#96CEB4',&#10;    community: '#FECA57',&#10;    general: '#DDA0DD'&#10;  };&#10;  return colors[category] || colors.general;&#10;};&#10;&#10;// Функция для форматирования даты&#10;const formatFullDate = (dateString: string): string =&gt; {&#10;  const date = new Date(dateString);&#10;  return date.toLocaleDateString('ru-RU', {&#10;    year: 'numeric',&#10;    month: 'long',&#10;    day: 'numeric',&#10;    hour: '2-digit',&#10;    minute: '2-digit'&#10;  });&#10;};&#10;&#10;interface NewsModalProps {&#10;  news: NewsItem | null;&#10;  onClose: () =&gt; void;&#10;}&#10;&#10;const NewsModal: React.FC&lt;NewsModalProps&gt; = ({ news, onClose }) =&gt; {&#10;  const isOpen = !!news;&#10;&#10;  useEffect(() =&gt; {&#10;    if (isOpen) {&#10;      // Блокируем скролл основной страницы&#10;      document.body.style.overflow = 'hidden';&#10;      TelegramWebApp.triggerHapticFeedback('medium');&#10;    } else {&#10;      document.body.style.overflow = 'unset';&#10;    }&#10;&#10;    return () =&gt; {&#10;      document.body.style.overflow = 'unset';&#10;    };&#10;  }, [isOpen]);&#10;&#10;  const handleOverlayClick = (e: React.MouseEvent) =&gt; {&#10;    if (e.target === e.currentTarget) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleClose = () =&gt; {&#10;    TelegramWebApp.triggerHapticFeedback('light');&#10;    onClose();&#10;  };&#10;&#10;  if (!news) return null;&#10;&#10;  return (&#10;    &lt;ModalOverlay $isOpen={isOpen} onClick={handleOverlayClick}&gt;&#10;      &lt;ModalContent $isOpen={isOpen}&gt;&#10;        &lt;ModalHeader&gt;&#10;          &lt;ModalTitle&gt;{news.title}&lt;/ModalTitle&gt;&#10;          &lt;CloseButton onClick={handleClose}&gt;×&lt;/CloseButton&gt;&#10;        &lt;/ModalHeader&gt;&#10;        &#10;        &lt;ModalBody&gt;&#10;          &lt;CategoryTag $category={news.category}&gt;&#10;            {news.category.toUpperCase()}&#10;          &lt;/CategoryTag&gt;&#10;          &#10;          {/* Поддержка медиа в модальном окне */}&#10;          {news.media &amp;&amp; (&#10;            &lt;ModalMediaContainer&gt;&#10;              {news.media.type === 'photo' &amp;&amp; (&#10;                &lt;ModalNewsImage &#10;                  src={news.media.url} &#10;                  alt={news.title}&#10;                  loading=&quot;lazy&quot;&#10;                /&gt;&#10;              )}&#10;              {news.media.type === 'video' &amp;&amp; (&#10;                &lt;ModalNewsVideo &#10;                  src={news.media.url}&#10;                  controls&#10;                  preload=&quot;metadata&quot;&#10;                  poster={news.media.thumbnail}&#10;                /&gt;&#10;              )}&#10;            &lt;/ModalMediaContainer&gt;&#10;          )}&#10;          &#10;          &lt;NewsContent&gt;{news.content}&lt;/NewsContent&gt;&#10;        &lt;/ModalBody&gt;&#10;        &#10;        &lt;NewsFooter&gt;&#10;          &lt;NewsSource&gt;&#10;            Источник: {news.source?.name || 'Telegram'}&#10;          &lt;/NewsSource&gt;&#10;          &lt;NewsDate&gt;&#10;            {formatFullDate(news.publish_date)}&#10;          &lt;/NewsDate&gt;&#10;        &lt;/NewsFooter&gt;&#10;      &lt;/ModalContent&gt;&#10;    &lt;/ModalOverlay&gt;&#10;  );&#10;};&#10;&#10;export default NewsModal;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/components/SearchBar.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/components/SearchBar.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import styled from 'styled-components';&#10;&#10;const SearchContainer = styled.div`&#10;  padding: 16px;&#10;  background-color: var(--tg-theme-bg-color, #ffffff);&#10;  border-bottom: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;`;&#10;&#10;const SearchInput = styled.input`&#10;  width: 100%;&#10;  padding: 12px 16px;&#10;  border: 1px solid var(--tg-theme-hint-color, #e0e0e0);&#10;  border-radius: 12px;&#10;  background-color: var(--tg-theme-secondary-bg-color, #f8f9fa);&#10;  color: var(--tg-theme-text-color, #000000);&#10;  font-size: 16px;&#10;  outline: none;&#10;  transition: border-color 0.2s ease;&#10;&#10;  &amp;:focus {&#10;    border-color: var(--tg-theme-button-color, #007AFF);&#10;  }&#10;&#10;  &amp;::placeholder {&#10;    color: var(--tg-theme-hint-color, #999999);&#10;  }&#10;`;&#10;&#10;interface SearchBarProps {&#10;  value: string;&#10;  onChange: (value: string) =&gt; void;&#10;  placeholder?: string;&#10;}&#10;&#10;const SearchBar: React.FC&lt;SearchBarProps&gt; = ({ value, onChange, placeholder = &quot;Поиск...&quot; }) =&gt; {&#10;  return (&#10;    &lt;SearchContainer&gt;&#10;      &lt;SearchInput&#10;        type=&quot;text&quot;&#10;        value={value}&#10;        onChange={(e) =&gt; onChange(e.target.value)}&#10;        placeholder={placeholder}&#10;      /&gt;&#10;    &lt;/SearchContainer&gt;&#10;  );&#10;};&#10;&#10;export default SearchBar;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts" />
              <option name="originalContent" value="// Telegram WebApp API для React&#10;class TelegramWebAppClass {&#10;  private webApp: any = null;&#10;&#10;  init() {&#10;    // Проверяем, что мы внутри Telegram&#10;    if (typeof window !== 'undefined' &amp;&amp; window.Telegram?.WebApp) {&#10;      this.webApp = window.Telegram.WebApp;&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;&#10;      // Устанавливаем цветовую схему&#10;      this.webApp.setHeaderColor('secondary_bg_color');&#10;      this.webApp.setBackgroundColor('bg_color');&#10;&#10;      console.log('Telegram WebApp инициализирован');&#10;    } else {&#10;      console.log('Telegram WebApp не доступен (разработка)');&#10;    }&#10;  }&#10;&#10;  getThemeParams() {&#10;    if (this.webApp?.themeParams) {&#10;      return this.webApp.themeParams;&#10;    }&#10;&#10;    // Дефолтная светлая тема для разработки&#10;    return {&#10;      bg_color: '#ffffff',&#10;      text_color: '#000000',&#10;      hint_color: '#999999',&#10;      link_color: '#007AFF',&#10;      button_color: '#007AFF',&#10;      button_text_color: '#ffffff',&#10;      secondary_bg_color: '#f8f9fa',&#10;      destructive_text_color: '#ff3b30'&#10;    };&#10;  }&#10;&#10;  triggerHapticFeedback(type: 'light' | 'medium' | 'heavy' | 'selection_change' = 'light') {&#10;    if (this.webApp?.HapticFeedback) {&#10;      switch (type) {&#10;        case 'light':&#10;          this.webApp.HapticFeedback.impactOccurred('light');&#10;          break;&#10;        case 'medium':&#10;          this.webApp.HapticFeedback.impactOccurred('medium');&#10;          break;&#10;        case 'heavy':&#10;          this.webApp.HapticFeedback.impactOccurred('heavy');&#10;          break;&#10;        case 'selection_change':&#10;          this.webApp.HapticFeedback.selectionChanged();&#10;          break;&#10;      }&#10;    }&#10;  }&#10;&#10;  showAlert(message: string) {&#10;    if (this.webApp?.showAlert) {&#10;      this.webApp.showAlert(message);&#10;    } else {&#10;      // eslint-disable-next-line no-alert&#10;      alert(message);&#10;    }&#10;  }&#10;&#10;  showConfirm(message: string, callback: (confirmed: boolean) =&gt; void) {&#10;    if (this.webApp?.showConfirm) {&#10;      this.webApp.showConfirm(message, callback);&#10;    } else {&#10;      // eslint-disable-next-line no-restricted-globals&#10;      callback(confirm(message));&#10;    }&#10;  }&#10;&#10;  openLink(url: string) {&#10;    if (this.webApp?.openLink) {&#10;      this.webApp.openLink(url);&#10;    } else {&#10;      window.open(url, '_blank');&#10;    }&#10;  }&#10;&#10;  close() {&#10;    if (this.webApp?.close) {&#10;      this.webApp.close();&#10;    }&#10;  }&#10;&#10;  getUser() {&#10;    return this.webApp?.initDataUnsafe?.user || null;&#10;  }&#10;&#10;  isExpanded() {&#10;    return this.webApp?.isExpanded || false;&#10;  }&#10;&#10;  getViewportHeight() {&#10;    return this.webApp?.viewportHeight || window.innerHeight;&#10;  }&#10;&#10;  onThemeChanged(callback: () =&gt; void) {&#10;    if (this.webApp) {&#10;      this.webApp.onEvent('themeChanged', callback);&#10;    }&#10;  }&#10;&#10;  onViewportChanged(callback: () =&gt; void) {&#10;    if (this.webApp) {&#10;      this.webApp.onEvent('viewportChanged', callback);&#10;    }&#10;  }&#10;}&#10;&#10;const TelegramWebApp = new TelegramWebAppClass();&#10;&#10;export default TelegramWebApp;&#10;" />
              <option name="updatedContent" value="// Telegram WebApp API для React&#10;class TelegramWebAppClass {&#10;  private webApp: any = null;&#10;&#10;  init() {&#10;    // Проверяем, что мы внутри Telegram&#10;    if (typeof window !== 'undefined' &amp;&amp; window.Telegram?.WebApp) {&#10;      this.webApp = window.Telegram.WebApp;&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;      &#10;      // Устанавливаем цветовую схему только если поддерживается&#10;      try {&#10;        if (this.webApp.setHeaderColor) {&#10;          this.webApp.setHeaderColor('secondary_bg_color');&#10;        }&#10;        if (this.webApp.setBackgroundColor) {&#10;          this.webApp.setBackgroundColor('bg_color');&#10;        }&#10;      } catch (e) {&#10;        console.log('Color methods not supported in this version');&#10;      }&#10;      &#10;      console.log('Telegram WebApp инициализирован');&#10;    } else {&#10;      console.log('Telegram WebApp не доступен (разработка)');&#10;    }&#10;  }&#10;&#10;  getThemeParams() {&#10;    if (this.webApp?.themeParams) {&#10;      return this.webApp.themeParams;&#10;    }&#10;&#10;    // Дефолтная светлая тема для разработки&#10;    return {&#10;      bg_color: '#ffffff',&#10;      text_color: '#000000',&#10;      hint_color: '#999999',&#10;      link_color: '#007AFF',&#10;      button_color: '#007AFF',&#10;      button_text_color: '#ffffff',&#10;      secondary_bg_color: '#f8f9fa',&#10;      destructive_text_color: '#ff3b30'&#10;    };&#10;  }&#10;&#10;  triggerHapticFeedback(type: 'light' | 'medium' | 'heavy' | 'selection_change' = 'light') {&#10;    // Проверяем поддержку HapticFeedback&#10;    if (this.webApp?.HapticFeedback) {&#10;      try {&#10;        switch (type) {&#10;          case 'light':&#10;            this.webApp.HapticFeedback.impactOccurred('light');&#10;            break;&#10;          case 'medium':&#10;            this.webApp.HapticFeedback.impactOccurred('medium');&#10;            break;&#10;          case 'heavy':&#10;            this.webApp.HapticFeedback.impactOccurred('heavy');&#10;            break;&#10;          case 'selection_change':&#10;            this.webApp.HapticFeedback.selectionChanged();&#10;            break;&#10;        }&#10;      } catch (e) {&#10;        console.log('HapticFeedback not supported in this version');&#10;      }&#10;    }&#10;  }&#10;&#10;  showAlert(message: string) {&#10;    if (this.webApp?.showAlert) {&#10;      this.webApp.showAlert(message);&#10;    } else {&#10;      // eslint-disable-next-line no-alert&#10;      alert(message);&#10;    }&#10;  }&#10;&#10;  showConfirm(message: string, callback: (confirmed: boolean) =&gt; void) {&#10;    if (this.webApp?.showConfirm) {&#10;      this.webApp.showConfirm(message, callback);&#10;    } else {&#10;      // eslint-disable-next-line no-restricted-globals&#10;      callback(confirm(message));&#10;    }&#10;  }&#10;&#10;  openLink(url: string) {&#10;    if (this.webApp?.openLink) {&#10;      this.webApp.openLink(url);&#10;    } else {&#10;      window.open(url, '_blank');&#10;    }&#10;  }&#10;&#10;  close() {&#10;    if (this.webApp?.close) {&#10;      this.webApp.close();&#10;    }&#10;  }&#10;&#10;  getUser() {&#10;    return this.webApp?.initDataUnsafe?.user || null;&#10;  }&#10;&#10;  isExpanded() {&#10;    return this.webApp?.isExpanded || false;&#10;  }&#10;&#10;  getViewportHeight() {&#10;    return this.webApp?.viewportHeight || window.innerHeight;&#10;  }&#10;&#10;  onThemeChanged(callback: () =&gt; void) {&#10;    if (this.webApp) {&#10;      this.webApp.onEvent('themeChanged', callback);&#10;    }&#10;  }&#10;&#10;  onViewportChanged(callback: () =&gt; void) {&#10;    if (this.webApp) {&#10;      this.webApp.onEvent('viewportChanged', callback);&#10;    }&#10;  }&#10;}&#10;&#10;const TelegramWebApp = new TelegramWebAppClass();&#10;&#10;export default TelegramWebApp;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts" />
              <option name="updatedContent" value="// Типы для Telegram WebApp API&#10;declare global {&#10;  interface Window {&#10;    Telegram?: {&#10;      WebApp: {&#10;        ready(): void;&#10;        expand(): void;&#10;        close(): void;&#10;        setHeaderColor(color: string): void;&#10;        setBackgroundColor(color: string): void;&#10;        showAlert(message: string): void;&#10;        showConfirm(message: string, callback: (confirmed: boolean) =&gt; void): void;&#10;        openLink(url: string): void;&#10;        onEvent(eventType: string, callback: () =&gt; void): void;&#10;        offEvent(eventType: string, callback: () =&gt; void): void;&#10;        isExpanded: boolean;&#10;        viewportHeight: number;&#10;        themeParams: {&#10;          bg_color?: string;&#10;          text_color?: string;&#10;          hint_color?: string;&#10;          link_color?: string;&#10;          button_color?: string;&#10;          button_text_color?: string;&#10;          secondary_bg_color?: string;&#10;          destructive_text_color?: string;&#10;        };&#10;        initDataUnsafe?: {&#10;          user?: {&#10;            id: number;&#10;            first_name: string;&#10;            last_name?: string;&#10;            username?: string;&#10;            language_code?: string;&#10;          };&#10;        };&#10;        HapticFeedback?: {&#10;          impactOccurred(style: 'light' | 'medium' | 'heavy'): void;&#10;          selectionChanged(): void;&#10;          notificationOccurred(type: 'error' | 'success' | 'warning'): void;&#10;        };&#10;      };&#10;    };&#10;  }&#10;}&#10;&#10;export {};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="fastapi==0.104.1&#10;uvicorn[standard]==0.24.0&#10;sqlalchemy==2.0.23&#10;python-dotenv==1.0.0&#10;requests==2.31.0&#10;apscheduler==3.10.4&#10;aiohttp==3.9.1&#10;feedparser==6.0.10&#10;pydantic==2.5.0&#10;psycopg2-binary==2.9.9" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/.env" />
              <option name="updatedContent" value="# База данных&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=your_bot_token_here&#10;WEBHOOK_URL=https://your-domain.com/telegram_webhook&#10;&#10;# Redis (опционально)&#10;REDIS_URL=redis://localhost:6379&#10;&#10;# Другие настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/__init__.py" />
              <option name="updatedContent" value="# API package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/news.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/news.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.main import app&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    SessionLocal = app.state.SessionLocal&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.db import SessionLocal  # Импортируем SessionLocal из db.py&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category,&#10;                # Добавляем медиа данные&#10;                &quot;media&quot;: {&#10;                    &quot;type&quot;: item.media_type,&#10;                    &quot;url&quot;: item.media_url,&#10;                    &quot;thumbnail&quot;: item.media_thumbnail,&#10;                    &quot;width&quot;: item.media_width,&#10;                    &quot;height&quot;: item.media_height&#10;                } if item.media_type and item.media_url else None,&#10;                # Добавляем информацию об источнике&#10;                &quot;source&quot;: {&#10;                    &quot;name&quot;: item.source.name if item.source else &quot;Unknown&quot;,&#10;                    &quot;type&quot;: item.source.type if item.source else &quot;unknown&quot;&#10;                } if item.source else None&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/config.py" />
              <option name="originalContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных - для Render&#10;# Временно жестко прописываем URL для Render&#10;DATABASE_URL = &quot;postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&quot;&#10;&#10;# Проверяем переменную окружения (если будет установлена в Render)&#10;env_db_url = os.getenv(&quot;DATABASE_URL&quot;)&#10;if env_db_url:&#10;    DATABASE_URL = env_db_url&#10;    print(f&quot;Using DATABASE_URL from environment: {DATABASE_URL[:50]}...&quot;)&#10;else:&#10;    print(f&quot;Using hardcoded DATABASE_URL for Render: {DATABASE_URL[:50]}...&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)&#10;&#10;# Логирование для отладки&#10;if __name__ == &quot;__main__&quot;:&#10;    print(f&quot;DATABASE_URL: {DATABASE_URL}&quot;)&#10;    print(f&quot;TOKEN: {TOKEN}&quot;)&#10;    print(f&quot;WEBHOOK_URL: {WEBHOOK_URL}&quot;)&#10;" />
              <option name="updatedContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных - для Render&#10;# Получаем DATABASE_URL из переменных окружения или используем дефолтную для Render&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&quot;)&#10;&#10;# Если используется локальный Docker, заменяем на внешний URL&#10;if &quot;postgresql://user:password@db:&quot; in DATABASE_URL:&#10;    DATABASE_URL = &quot;postgresql://giftpropaganda_db_user:cSLpUy9JBOc1KEzf7tBCEZtDxQU61KV5@dpg-d21dudp5pdvs73fqkaeg-a.oregon-postgres.render.com/giftpropaganda_db&quot;&#10;    print(&quot;Заменен Docker DATABASE_URL на Render PostgreSQL&quot;)&#10;&#10;print(f&quot;Using DATABASE_URL: {DATABASE_URL[:50]}...&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;8429342375:AAFl55U3d2jiq3bm4UNTyDrbB0rztFTio2I&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;https://giftpropaganda.onrender.com&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)&#10;&#10;# Логирование для отладки&#10;if __name__ == &quot;__main__&quot;:&#10;    print(f&quot;DATABASE_URL: {DATABASE_URL}&quot;)&#10;    print(f&quot;TOKEN: {TOKEN}&quot;)&#10;    print(f&quot;WEBHOOK_URL: {WEBHOOK_URL}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine&#10;from sqlalchemy.orm import sessionmaker&#10;from server.config import DATABASE_URL&#10;from server.models import Base&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;&#10;# Создание таблиц (если нужно)&#10;Base.metadata.create_all(bind=engine)&#10;&#10;" />
              <option name="updatedContent" value="from sqlalchemy import create_engine&#10;from sqlalchemy.orm import sessionmaker&#10;from server.config import DATABASE_URL&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Добавляем CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&#10;        &quot;http://localhost:3000&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;,&#10;        &quot;https://gift-propaganda.vercel.app&quot;,&#10;        &quot;https://giftpropaganda.onrender.com&quot;  # Обновлен на реальный домен&#10;    ],&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],  # Разрешаем все HTTP методы&#10;    allow_headers=[&quot;*&quot;],  # Разрешаем все заголовки&#10;)&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: WEBHOOK_URL}&#10;    response = requests.post(url, data=data)&#10;    if response.status_code == 200:&#10;        logger.info(&quot;Webhook установлен успешно&quot;)&#10;    else:&#10;        logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal  # Сохраняем SessionLocal&#10;    setup_webhook()&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()  # Создаём новую сессию&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()  # Закрываем сессию&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()  # Корректно закрываем engine&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
              <option name="updatedContent" value="from fastapi import FastAPI, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Обновленные CORS настройки для всех доменов&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&#10;        &quot;http://localhost:3000&quot;,&#10;        &quot;http://127.0.0.1:3000&quot;, &#10;        &quot;https://gift-propaganda.vercel.app&quot;,&#10;        &quot;https://giftpropaganda.onrender.com&quot;,&#10;        &quot;*&quot;  # Временно разрешаем все домены для отладки&#10;    ],&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],&#10;    allow_headers=[&quot;*&quot;],&#10;)&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    if not TOKEN or TOKEN == &quot;YOUR_BOT_TOKEN&quot;:&#10;        logger.warning(&quot;Telegram token не настроен, пропускаем настройку webhook&quot;)&#10;        return&#10;        &#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: f&quot;{WEBHOOK_URL}/webhook&quot;}&#10;    try:&#10;        response = requests.post(url, data=data)&#10;        if response.status_code == 200:&#10;            logger.info(&quot;Webhook установлен успешно&quot;)&#10;        else:&#10;            logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;    except Exception as e:&#10;        logger.error(f&quot;Ошибка при настройке webhook: {e}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    # Логируем переменные окружения для отладки&#10;    logger.info(f&quot;DATABASE_URL: {DATABASE_URL[:50]}...&quot;)&#10;    logger.info(f&quot;TOKEN: {'SET' if TOKEN else 'NOT SET'}&quot;)&#10;    logger.info(f&quot;WEBHOOK_URL: {WEBHOOK_URL}&quot;)&#10;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal&#10;    setup_webhook()&#10;    &#10;    # Запускаем периодическое обновление&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;# Добавляем простой роут для проверки работы API&#10;@app.get(&quot;/&quot;)&#10;async def root():&#10;    return {&quot;message&quot;: &quot;Gift Propaganda News API&quot;, &quot;status&quot;: &quot;running&quot;}&#10;&#10;@app.get(&quot;/health&quot;)&#10;async def health_check():&#10;    return {&quot;status&quot;: &quot;healthy&quot;, &quot;database&quot;: &quot;connected&quot;}&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models.py" />
              <option name="originalContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;), nullable=True)  # Разрешаем NULL&#10;    title = Column(String(500), index=True)  # Увеличиваем размер для длинных заголовков&#10;    content = Column(Text)  # Используем Text для длинного контента&#10;    link = Column(String(500))  # Увеличиваем размер для длинных ссылок&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации&#10;" />
              <option name="updatedContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, JSON&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;), nullable=True)  # Разрешаем NULL&#10;    title = Column(String(500), index=True)  # Увеличиваем размер для длинных заголовков&#10;    content = Column(Text)  # Используем Text для длинного контента&#10;    link = Column(String(500))  # Увеличиваем размер для длинных ссылок&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    &#10;    # Добавляем поля для медиа контента&#10;    media_type = Column(String(20), nullable=True)  # 'photo', 'video', null&#10;    media_url = Column(String(1000), nullable=True)  # URL медиа файла&#10;    media_thumbnail = Column(String(1000), nullable=True)  # URL превью (для видео)&#10;    media_width = Column(Integer, nullable=True)  # Ширина медиа&#10;    media_height = Column(Integer, nullable=True)  # Высота медиа&#10;    &#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/__init__.py" />
              <option name="updatedContent" value="# Parsers package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/rss.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/rss.py" />
              <option name="updatedContent" value="import feedparser&#10;import logging&#10;from sqlalchemy.orm import Session&#10;from typing import List, Dict, Any&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;async def fetch_rss_feeds(session: Session) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Получение новостей из RSS источников&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Fetching RSS feeds...&quot;)&#10;        &#10;        # Список RSS источников&#10;        rss_sources = [&#10;            {&quot;url&quot;: &quot;https://vc.ru/rss&quot;, &quot;name&quot;: &quot;VC.ru&quot;, &quot;category&quot;: &quot;tech&quot;},&#10;            {&quot;url&quot;: &quot;https://forklog.com/feed/&quot;, &quot;name&quot;: &quot;ForkLog&quot;, &quot;category&quot;: &quot;crypto&quot;}&#10;        ]&#10;        &#10;        articles = []&#10;        for source in rss_sources:&#10;            try:&#10;                feed = feedparser.parse(source[&quot;url&quot;])&#10;                for entry in feed.entries[:5]:  # Берем только 5 последних&#10;                    article = {&#10;                        &quot;title&quot;: entry.title,&#10;                        &quot;link&quot;: entry.link,&#10;                        &quot;description&quot;: getattr(entry, 'summary', ''),&#10;                        &quot;source&quot;: source[&quot;name&quot;],&#10;                        &quot;category&quot;: source[&quot;category&quot;]&#10;                    }&#10;                    articles.append(article)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error parsing RSS {source['url']}: {e}&quot;)&#10;        &#10;        logger.info(f&quot;RSS feeds fetched successfully, {len(articles)} articles&quot;)&#10;        return articles&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Error fetching RSS feeds: {e}&quot;)&#10;        return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/telegram.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/telegram.py" />
              <option name="originalContent" value="import asyncio&#10;from typing import List, Dict&#10;from datetime import datetime&#10;from server.parsers.telegram_news_service import telegram_news_service&#10;from server.models import NewsItem, Source&#10;from sqlalchemy.orm import Session&#10;&#10;async def fetch_telegram_channels(session: Session):&#10;    try:&#10;        # Получаем все новости&#10;        news = await telegram_news_service.get_all_news(category='all', limit=50)&#10;&#10;        # Кэш для источников, чтобы не создавать дубликаты&#10;        sources_cache = {}&#10;&#10;        for item in news:&#10;            # Создаем или находим источник&#10;            source_name = item.get('source', 'Unknown')&#10;            source_url = item.get('link', '')&#10;            category = item.get('category', 'general')&#10;&#10;            # Проверяем, есть ли источник в кэше&#10;            source_key = f&quot;{source_name}_{source_url}&quot;&#10;            if source_key not in sources_cache:&#10;                # Ищем существующий источник&#10;                existing_source = session.query(Source).filter(&#10;                    Source.name == source_name,&#10;                    Source.url == source_url&#10;                ).first()&#10;&#10;                if existing_source:&#10;                    sources_cache[source_key] = existing_source.id&#10;                else:&#10;                    # Создаем новый источник&#10;                    new_source = Source(&#10;                        type=&quot;telegram&quot;,&#10;                        url=source_url,&#10;                        name=source_name,&#10;                        category=category,&#10;                        enabled=1&#10;                    )&#10;                    session.add(new_source)&#10;                    session.flush()  # Получаем ID&#10;                    sources_cache[source_key] = new_source.id&#10;&#10;            source_id = sources_cache[source_key]&#10;&#10;            # Проверяем, существует ли уже такая новость&#10;            existing_news = session.query(NewsItem).filter(&#10;                NewsItem.title == item['title'],&#10;                NewsItem.source_id == source_id&#10;            ).first()&#10;&#10;            if not existing_news:&#10;                # Парсим дату&#10;                try:&#10;                    if isinstance(item['date'], str):&#10;                        publish_date = datetime.fromisoformat(item['date'].replace('Z', '+00:00'))&#10;                    else:&#10;                        publish_date = item['date']&#10;                except:&#10;                    publish_date = datetime.now()&#10;&#10;                # Создаем новость&#10;                db_item = NewsItem(&#10;                    source_id=source_id,&#10;                    title=item['title'],&#10;                    content=item['text'],&#10;                    link=item['link'],&#10;                    publish_date=publish_date,&#10;                    category=item['category']&#10;                )&#10;                session.add(db_item)&#10;&#10;        session.commit()&#10;        print(f&quot;Добавлено новостей в базу&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;Ошибка при загрузке каналов: {e}&quot;)&#10;        session.rollback()&#10;        raise e&#10;" />
              <option name="updatedContent" value="import asyncio&#10;from typing import List, Dict&#10;from datetime import datetime&#10;from server.parsers.telegram_news_service import telegram_news_service&#10;from server.models import NewsItem, Source&#10;from sqlalchemy.orm import Session&#10;&#10;async def fetch_telegram_channels(session: Session):&#10;    try:&#10;        # Получаем все новости&#10;        news = await telegram_news_service.get_all_news(category='all', limit=50)&#10;        &#10;        # Кэш для источников, чтобы не создавать дубликаты&#10;        sources_cache = {}&#10;        &#10;        for item in news:&#10;            # Создаем или находим источник&#10;            source_name = item.get('source', 'Unknown')&#10;            source_url = item.get('link', '')&#10;            category = item.get('category', 'general')&#10;            &#10;            # Проверяем, есть ли источник в кэше&#10;            source_key = f&quot;{source_name}_{source_url}&quot;&#10;            if source_key not in sources_cache:&#10;                # Ищем существующий источник&#10;                existing_source = session.query(Source).filter(&#10;                    Source.name == source_name,&#10;                    Source.url == source_url&#10;                ).first()&#10;                &#10;                if existing_source:&#10;                    sources_cache[source_key] = existing_source.id&#10;                else:&#10;                    # Создаем новый источник&#10;                    new_source = Source(&#10;                        type=&quot;telegram&quot;,&#10;                        url=source_url,&#10;                        name=source_name,&#10;                        category=category,&#10;                        enabled=1&#10;                    )&#10;                    session.add(new_source)&#10;                    session.flush()  # Получаем ID&#10;                    sources_cache[source_key] = new_source.id&#10;            &#10;            source_id = sources_cache[source_key]&#10;            &#10;            # Проверяем, существует ли уже такая новость&#10;            existing_news = session.query(NewsItem).filter(&#10;                NewsItem.title == item['title'],&#10;                NewsItem.source_id == source_id&#10;            ).first()&#10;            &#10;            if not existing_news:&#10;                # Парсим дату&#10;                try:&#10;                    if isinstance(item['date'], str):&#10;                        publish_date = datetime.fromisoformat(item['date'].replace('Z', '+00:00'))&#10;                    else:&#10;                        publish_date = item['date']&#10;                except:&#10;                    publish_date = datetime.now()&#10;                &#10;                # Извлекаем медиа данные&#10;                media = item.get('media')&#10;                media_type = None&#10;                media_url = None&#10;                media_thumbnail = None&#10;                media_width = None&#10;                media_height = None&#10;                &#10;                if media:&#10;                    media_type = media.get('type')&#10;                    media_url = media.get('url')&#10;                    media_thumbnail = media.get('thumbnail')&#10;                    media_width = media.get('width')&#10;                    media_height = media.get('height')&#10;                &#10;                # Создаем новость с медиа данными&#10;                db_item = NewsItem(&#10;                    source_id=source_id,&#10;                    title=item['title'],&#10;                    content=item['text'],&#10;                    link=item['link'],&#10;                    publish_date=publish_date,&#10;                    category=item['category'],&#10;                    # Добавляем медиа поля&#10;                    media_type=media_type,&#10;                    media_url=media_url,&#10;                    media_thumbnail=media_thumbnail,&#10;                    media_width=media_width,&#10;                    media_height=media_height&#10;                )&#10;                session.add(db_item)&#10;        &#10;        session.commit()&#10;        print(f&quot;Добавлено новостей в базу&quot;)&#10;        &#10;    except Exception as e:&#10;        print(f&quot;Ошибка при загрузке каналов: {e}&quot;)&#10;        session.rollback()&#10;        raise e" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/telegram_news_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/telegram_news_service.py" />
              <option name="originalContent" value="import aiohttp&#10;import asyncio&#10;import feedparser&#10;from typing import List, Dict, Any, Optional&#10;import json&#10;from datetime import datetime, timedelta&#10;import logging&#10;import re&#10;import hashlib&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class TelegramNewsService:&#10;    &quot;&quot;&quot;Сервис для получения новостей из Telegram каналов и RSS источников&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Telegram каналы согласно ТЗ - ключевые источники по темам подарков, NFT и крипто&#10;        self.channels = [&#10;            # Каналы о подарках и бонусах&#10;            {'username': 'gift_newstg', 'name': 'Gift News TG', 'category': 'gifts'},&#10;            {'username': 'giftsutya', 'name': 'Gift Sutya', 'category': 'gifts'},&#10;            {'username': 'diruil_gifts', 'name': 'Diruil Gifts', 'category': 'gifts'},&#10;            {'username': 'giftnews', 'name': 'Gift News', 'category': 'gifts'},&#10;            {'username': 'BunnyStarsShop', 'name': 'Bunny Stars Shop', 'category': 'gifts'},&#10;            {'username': 'nft_podarki', 'name': 'NFT Подарки', 'category': 'gifts'},&#10;&#10;            # Технологии и инновации&#10;            {'username': 'westik', 'name': 'Westik', 'category': 'tech'},&#10;&#10;            # Сообщества и чаты&#10;            {'username': 'OHUENKOchat', 'name': 'OHUENKO Chat', 'category': 'community'},&#10;            {'username': 'community', 'name': 'Community', 'category': 'community'},&#10;            {'username': 'groza', 'name': 'Groza', 'category': 'community'},&#10;&#10;            # Криптовалюты и блокчейн&#10;            {'username': 'omicron', 'name': 'Omicron', 'category': 'crypto'},&#10;            {'username': 'tontopic_1', 'name': 'TON Topic', 'category': 'crypto'},&#10;            {'username': 'procryptodoping', 'name': 'Pro Crypto Doping', 'category': 'crypto'},&#10;&#10;            # NFT и цифровое искусство&#10;            {'username': 'nextgen_NFT', 'name': 'NextGen NFT', 'category': 'nft'},&#10;            {'username': 'snoopdogg', 'name': 'Snoop Dogg', 'category': 'nft'}&#10;        ]&#10;&#10;        # RSS источники согласно ТЗ - до 5 проверенных лент&#10;        self.rss_sources = [&#10;            {'url': 'https://vc.ru/rss', 'name': 'VC.ru', 'category': 'tech'},&#10;            {'url': 'https://forklog.com/feed/', 'name': 'ForkLog', 'category': 'crypto'},&#10;            {'url': 'https://www.coindesk.com/arc/outboundfeeds/rss/', 'name': 'CoinDesk', 'category': 'crypto'},&#10;            {'url': 'https://cointelegraph.com/rss', 'name': 'Cointelegraph', 'category': 'crypto'},&#10;            {'url': 'https://habr.com/ru/rss/hub/nft/all/', 'name': 'Habr NFT', 'category': 'nft'}&#10;        ]&#10;&#10;        self.cache = {}&#10;        self.cache_ttl = timedelta(minutes=30)  # Кэш на 30 минут согласно ТЗ&#10;&#10;        # Ключевые слова для категоризации согласно ТЗ&#10;        self.keywords = {&#10;            'gifts': [&#10;                'подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка',&#10;                'акция', 'розыгрыш', 'бонус', 'даром', 'гифт', 'gift', 'freebie',&#10;                'раздача', 'конкурс', 'приз', 'награда', 'cashback', 'кэшбек'&#10;            ],&#10;            'nft': [&#10;                'nft', 'нфт', 'токен', 'коллекция', 'мета', 'opensea', 'digital art',&#10;                'коллекционный', 'цифровое искусство', 'метавселенная', 'avatar',&#10;                'аватар', 'pfp', 'mint', 'минт', 'drop', 'дроп', 'rare', 'раритет'&#10;            ],&#10;            'crypto': [&#10;                'криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф',&#10;                'defi', 'торги', 'курс', 'btc', 'eth', 'usdt', 'binance', 'трейдинг',&#10;                'стейкинг', 'майнинг', 'altcoin', 'альткоин', 'pump', 'dump', 'hodl'&#10;            ],&#10;            'tech': [&#10;                'технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап',&#10;                'инновации', 'ai', 'ии', 'machine learning', 'блокчейн', 'веб3',&#10;                'app', 'приложение', 'software', 'hardware', 'gadget', 'гаджет'&#10;            ],&#10;            'community': [&#10;                'сообщество', 'чат', 'общение', 'форум', 'дискуссия', 'мнение',&#10;                'обсуждение', 'новости', 'анонс', 'встреча', 'event', 'мероприятие'&#10;            ]&#10;        }&#10;&#10;    def categorize_content(self, title: str, description: str = &quot;&quot;) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Автоматическая категоризация контента по ключевым словам согласно ТЗ&#10;        Приоритет: gifts &gt; crypto &gt; nft &gt; tech &gt; community&#10;        &quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        # Подсчитываем совпадения для каждой категории&#10;        category_scores = {}&#10;        for category, keywords in self.keywords.items():&#10;            score = sum(1 for keyword in keywords if keyword in content)&#10;            if score &gt; 0:&#10;                category_scores[category] = score&#10;&#10;        if not category_scores:&#10;            return 'general'&#10;&#10;        # Возвращаем категорию с наибольшим количеством совпадений&#10;        # При равенстве очков используем приоритет&#10;        priority = ['gifts', 'crypto', 'nft', 'tech', 'community']&#10;&#10;        max_score = max(category_scores.values())&#10;        best_categories = [cat for cat, score in category_scores.items() if score == max_score]&#10;&#10;        for priority_cat in priority:&#10;            if priority_cat in best_categories:&#10;                return priority_cat&#10;&#10;        return list(category_scores.keys())[0]  # Fallback&#10;&#10;    async def fetch_telegram_channel(self, channel_username: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получение новостей из Telegram канала через веб-скрапинг&#10;        Согласно ТЗ - интеграция с Telegram каналами для получения актуальных новостей&#10;        &quot;&quot;&quot;&#10;        try:&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == channel_username), None)&#10;            if not channel_data:&#10;                logger.warning(f&quot;Channel {channel_username} not found in configured channels&quot;)&#10;                return []&#10;&#10;            # Используем публичный API Telegram для получения постов&#10;            url = f&quot;https://t.me/s/{channel_username}&quot;&#10;&#10;            async with aiohttp.ClientSession() as session:&#10;                try:&#10;                    async with session.get(url, timeout=10) as response:&#10;                        if response.status == 200:&#10;                            html_content = await response.text()&#10;                            return self._parse_telegram_html(html_content, channel_data)&#10;                        else:&#10;                            logger.warning(f&quot;Failed to fetch {url}, status: {response.status}&quot;)&#10;                            return self._generate_mock_posts(channel_data)&#10;                except aiohttp.ClientTimeout:&#10;                    logger.warning(f&quot;Timeout fetching {url}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;                except Exception as e:&#10;                    logger.warning(f&quot;Error fetching {url}: {e}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in fetch_telegram_channel for {channel_username}: {e}&quot;)&#10;            return []&#10;&#10;    def _parse_telegram_html(self, html_content: str, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Парсинг HTML содержимого Telegram канала&quot;&quot;&quot;&#10;        import re&#10;        from html import unescape&#10;&#10;        posts = []&#10;&#10;        # Простой парсер для получения постов из HTML&#10;        # В реальном проекте лучше использовать BeautifulSoup&#10;        post_pattern = r'&lt;div class=&quot;tgme_widget_message.*?&lt;/div&gt;\s*&lt;/div&gt;\s*&lt;/div&gt;'&#10;        text_pattern = r'&lt;div class=&quot;tgme_widget_message_text.*?&quot;.*?&gt;(.*?)&lt;/div&gt;'&#10;        date_pattern = r'&lt;time.*?datetime=&quot;([^&quot;]+)&quot;'&#10;&#10;        post_matches = re.findall(post_pattern, html_content, re.DOTALL)&#10;&#10;        for i, post_html in enumerate(post_matches[:10]):  # Берем только первые 10 постов&#10;            # Извлекаем текст поста&#10;            text_match = re.search(text_pattern, post_html, re.DOTALL)&#10;            text = &quot;&quot;&#10;            if text_match:&#10;                text = unescape(re.sub(r'&lt;[^&gt;]+&gt;', '', text_match.group(1)))&#10;                text = text.strip()[:300] + &quot;...&quot; if len(text) &gt; 300 else text.strip()&#10;&#10;            # Извлекаем дату&#10;            date_match = re.search(date_pattern, post_html)&#10;            date = datetime.now().isoformat()&#10;            if date_match:&#10;                try:&#10;                    date = datetime.fromisoformat(date_match.group(1).replace('Z', '+00:00')).isoformat()&#10;                except:&#10;                    pass&#10;&#10;            if text:  # Только если удалось извлечь текст&#10;                # Генерируем заголовок из первых слов&#10;                title = text.split('.')[0][:100] if text else f&quot;Пост от {channel_data['name']}&quot;&#10;&#10;                post = {&#10;                    'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text[:50]}&quot;.encode()).hexdigest(),&#10;                    'title': title,&#10;                    'text': text,&#10;                    'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                    'date': date,&#10;                    'source': channel_data['name'],&#10;                    'category': channel_data['category'],&#10;                    'channel': channel_data['username']&#10;                }&#10;&#10;                posts.append(post)&#10;&#10;        if not posts:  # Если парсинг не удался, используем мок данные&#10;            return self._generate_mock_posts(channel_data)&#10;&#10;        return posts&#10;&#10;    def _generate_mock_posts(self, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Генерация мок данных для канала согласно ТЗ&quot;&quot;&quot;&#10;        posts = []&#10;        base_time = datetime.now()&#10;&#10;        # Контент в зависимости от категории канала&#10;        content_templates = {&#10;            'gifts': [&#10;                &quot; Новые бесплатные подарки! Успейте получить эксклюзивные бонусы&quot;,&#10;                &quot; Промокоды на скидки до 70%! Ограниченное предложение&quot;,&#10;                &quot; Розыгрыш ценных призов среди подписчиков канала&quot;,&#10;                &quot;️ Лучшие предложения дня - не пропустите!&quot;&#10;            ],&#10;            'crypto': [&#10;                &quot; Анализ рынка: Bitcoin показывает рост на 5%&quot;,&#10;                &quot; Новые возможности DeFi инвестиций - обзор проектов&quot;,&#10;                &quot; Перспективные альткоины для долгосрочных инвестиций&quot;,&#10;                &quot;⚡ Срочные новости: крупные движения на криптовалютном рынке&quot;&#10;            ],&#10;            'nft': [&#10;                &quot;️ Новая коллекция NFT от известного художника уже в продаже&quot;,&#10;                &quot; Раритетные токены на аукционе - последний шанс приобрести&quot;,&#10;                &quot; Обзор лучших NFT художников недели&quot;,&#10;                &quot; Статистика NFT рынка: рост объемов торгов на 15%&quot;&#10;            ],&#10;            'tech': [&#10;                &quot; Революционные технологии 2025 года - что нас ждет&quot;,&#10;                &quot; Обзор новейших гаджетов от мировых производителей&quot;,&#10;                &quot; Стартапы в сфере ИИ привлекли рекордные инвестиции&quot;,&#10;                &quot; ТОП мобильных приложений для повышения продуктивности&quot;&#10;            ],&#10;            'community': [&#10;                &quot; Обсуждение актуальных тем в нашем сообществе&quot;,&#10;                &quot; Важные новости и обновления для участников&quot;,&#10;                &quot; Анонс предстоящих мероприятий и встреч&quot;,&#10;                &quot; Полезные советы и рекомендации от экспертов&quot;&#10;            ]&#10;        }&#10;&#10;        templates = content_templates.get(channel_data['category'], content_templates['community'])&#10;&#10;        for i in range(5):  # Генерируем 5 постов&#10;            post_time = base_time - timedelta(hours=i * 4 + hash(channel_data['username']) % 12)&#10;&#10;            text = templates[i % len(templates)]&#10;            title = text.split('.')[0][:80] + (&quot;...&quot; if len(text.split('.')[0]) &gt; 80 else &quot;&quot;)&#10;&#10;            posts.append({&#10;                'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text}&quot;.encode()).hexdigest(),&#10;                'title': title,&#10;                'text': text,&#10;                'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                'date': post_time.isoformat(),&#10;                'source': channel_data['name'],&#10;                'category': channel_data['category'],&#10;                'channel': channel_data['username']&#10;            })&#10;&#10;        return posts&#10;        &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        for category, keywords in self.keywords.items():&#10;            if any(keyword in content for keyword in keywords):&#10;                return category&#10;&#10;        return 'general'&#10;&#10;    async def fetch_rss_feed(self, source: Dict[str, str]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            # Используем feedparser для парсинга RSS&#10;            feed = feedparser.parse(source['url'])&#10;&#10;            if not feed.entries:&#10;                logger.warning(f&quot;No entries found in RSS feed: {source['url']}&quot;)&#10;                return []&#10;&#10;            articles = []&#10;            for entry in feed.entries[:10]:  # Берем только последние 10 новостей&#10;                # Получаем описание из различных полей&#10;                description = &quot;&quot;&#10;                if hasattr(entry, 'summary'):&#10;                    description = entry.summary&#10;                elif hasattr(entry, 'description'):&#10;                    description = entry.description&#10;                elif hasattr(entry, 'content'):&#10;                    description = entry.content[0].value if entry.content else &quot;&quot;&#10;&#10;                # Очищаем HTML теги&#10;                description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                description = description[:200] + &quot;...&quot; if len(description) &gt; 200 else description&#10;&#10;                # Получаем дату публикации&#10;                pub_date = datetime.now()&#10;                if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.published_parsed))&#10;                elif hasattr(entry, 'updated_parsed') and entry.updated_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.updated_parsed))&#10;&#10;                # Автоматическая категоризация&#10;                auto_category = self.categorize_content(entry.title, description)&#10;                final_category = source.get('category', auto_category)&#10;&#10;                article = {&#10;                    'id': hashlib.md5((entry.link + entry.title).encode()).hexdigest(),&#10;                    'title': entry.title,&#10;                    'text': description,&#10;                    'link': entry.link,&#10;                    'date': pub_date.isoformat(),&#10;                    'source': source['name'],&#10;                    'category': final_category,&#10;                    'channel': 'rss_' + source['name'].lower().replace(' ', '_')&#10;                }&#10;&#10;                articles.append(article)&#10;&#10;            return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS feed {source['url']}: {e}&quot;)&#10;            return []&#10;        &quot;&quot;&quot;Получить информацию о канале через Telegram API&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока возвращаем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return None&#10;&#10;            return {&#10;                'username': username,&#10;                'title': channel_data['name'],&#10;                'description': f&quot;Канал {channel_data['name']} - {channel_data['category']}&quot;,&#10;                'subscribers_count': 1000 + hash(username) % 50000,  # Мок количества подписчиков&#10;                'category': channel_data['category']&#10;            }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channel info for {username}: {e}&quot;)&#10;            return None&#10;&#10;    async def get_channel_posts(self, username: str, limit: int = 10) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить последние посты из канала&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока генерируем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return []&#10;&#10;            posts = []&#10;            base_time = datetime.now()&#10;&#10;            for i in range(limit):&#10;                post_time = base_time - timedelta(hours=i * 2 + hash(username + str(i)) % 24)&#10;&#10;                # Генерируем контент на основе категории&#10;                if channel_data['category'] == 'gifts':&#10;                    titles = [&#10;                        f&quot; Новые бесплатные подарки в {channel_data['name']}!&quot;,&#10;                        f&quot; Эксклюзивные промокоды и скидки&quot;,&#10;                        f&quot; Розыгрыш призов для подписчиков&quot;,&#10;                        f&quot;️ Лучшие предложения дня&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'crypto':&#10;                    titles = [&#10;                        f&quot; Анализ рынка криптовалют&quot;,&#10;                        f&quot; Новые возможности для инвестиций&quot;,&#10;                        f&quot; Обзор перспективных проектов&quot;,&#10;                        f&quot;⚡ Быстрые новости из мира крипто&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'nft':&#10;                    titles = [&#10;                        f&quot;️ Новые NFT коллекции&quot;,&#10;                        f&quot; Раритетные токены на аукционе&quot;,&#10;                        f&quot; Обзор NFT художников&quot;,&#10;                        f&quot; Статистика NFT рынка&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'tech':&#10;                    titles = [&#10;                        f&quot; Новости технологий&quot;,&#10;                        f&quot; Обзор гаджетов&quot;,&#10;                        f&quot; Инновации в IT&quot;,&#10;                        f&quot; Мобильные приложения&quot;&#10;                    ]&#10;                else:&#10;                    titles = [&#10;                        f&quot; Новости от {channel_data['name']}&quot;,&#10;                        f&quot;ℹ️ Важные обновления&quot;,&#10;                        f&quot; Полезная информация&quot;,&#10;                        f&quot; Горячие темы&quot;&#10;                    ]&#10;&#10;                title = titles[i % len(titles)]&#10;&#10;                posts.append({&#10;                    'id': f&quot;{username}_{i}&quot;,&#10;                    'title': title,&#10;                    'text': f&quot;Интересный контент от канала {channel_data['name']}. Подписывайтесь для получения актуальных новостей!&quot;,&#10;                    'date': post_time.isoformat(),&#10;                    'views': 100 + hash(username + str(i)) % 5000,&#10;                    'link': f&quot;https://t.me/{username}&quot;,&#10;                    'channel': username,&#10;                    'category': channel_data['category']&#10;                })&#10;&#10;            return posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting posts for {username}: {e}&quot;)&#10;            return []&#10;&#10;    async def get_all_news(self, category: str = 'all', limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получить новости из всех источников согласно ТЗ:&#10;        - Telegram каналы (основные источники)&#10;        - RSS ленты (дополнительные источники)&#10;        - Автоматическая категоризация и дедупликация&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Проверяем кэш&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, cached_time = self.cache[cache_key]&#10;                if datetime.now() - cached_time &lt; self.cache_ttl:&#10;                    logger.info(f&quot;Returning cached news for {category}, {len(cached_data)} items&quot;)&#10;                    return cached_data&#10;&#10;            all_posts = []&#10;&#10;            # 1. Получаем данные из Telegram каналов (приоритетный источник согласно ТЗ)&#10;            telegram_channels = self.channels&#10;            if category != 'all':&#10;                telegram_channels = [ch for ch in self.channels if ch['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(telegram_channels)} Telegram channels&quot;)&#10;&#10;            # Получаем посты из Telegram каналов&#10;            telegram_tasks = []&#10;            for channel in telegram_channels:&#10;                telegram_tasks.append(self.fetch_telegram_channel(channel['username']))&#10;&#10;            telegram_results = await asyncio.gather(*telegram_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(telegram_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} posts from {telegram_channels[i]['username']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching posts from {telegram_channels[i]['username']}: {result}&quot;)&#10;&#10;            # 2. Получаем данные из RSS источников (дополнительный источник)&#10;            rss_sources = self.rss_sources&#10;            if category != 'all':&#10;                rss_sources = [src for src in self.rss_sources if src['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(rss_sources)} RSS sources&quot;)&#10;&#10;            # Получаем статьи из RSS&#10;            rss_tasks = []&#10;            for source in rss_sources:&#10;                rss_tasks.append(self.fetch_rss_feed(source))&#10;&#10;            rss_results = await asyncio.gather(*rss_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(rss_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} articles from {rss_sources[i]['name']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching RSS from {rss_sources[i]['url']}: {result}&quot;)&#10;&#10;            # 3. Обработка и дедупликация согласно ТЗ&#10;            # Удаляем дубликаты по заголовку и ссылке&#10;            seen = set()&#10;            unique_posts = []&#10;            for post in all_posts:&#10;                # Создаем ключ для дедупликации&#10;                title_clean = re.sub(r'[^\w\s]', '', post['title'].lower()).strip()&#10;                key = (title_clean, post.get('link', ''))&#10;                if key not in seen:&#10;                    seen.add(key)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # 4. Сортировка по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(&#10;                    key=lambda x: datetime.fromisoformat(x['date'].replace('Z', '+00:00')),&#10;                    reverse=True&#10;                )&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # 5. Ограничиваем количество согласно ТЗ&#10;            final_posts = unique_posts[:limit]&#10;&#10;            # 6. Сохраняем в кэш на 30 минут согласно ТЗ&#10;            self.cache[cache_key] = (final_posts, datetime.now())&#10;&#10;            logger.info(f&quot;Returning {len(final_posts)} news items for category '{category}'&quot;)&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in get_all_news: {e}&quot;)&#10;            # В случае ошибки возвращаем данные из кэша, если есть&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, _ = self.cache[cache_key]&#10;                logger.info(&quot;Returning stale cached data due to error&quot;)&#10;                return cached_data&#10;            return []&#10;&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting all news: {e}&quot;)&#10;            return []&#10;&#10;    async def get_channels_info(self) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить информацию о всех каналах&quot;&quot;&quot;&#10;        try:&#10;            tasks = []&#10;            for channel in self.channels:&#10;                tasks.append(self.get_channel_info(channel['username']))&#10;&#10;            results = await asyncio.gather(*tasks, return_exceptions=True)&#10;&#10;            channels_info = []&#10;            for result in results:&#10;                if isinstance(result, dict):&#10;                    channels_info.append(result)&#10;&#10;            return channels_info&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channels info: {e}&quot;)&#10;            return []&#10;&#10;&#10;# Глобальный экземпляр сервиса&#10;telegram_news_service = TelegramNewsService()&#10;" />
              <option name="updatedContent" value="import aiohttp&#10;import asyncio&#10;import feedparser&#10;from typing import List, Dict, Any, Optional&#10;import json&#10;from datetime import datetime, timedelta&#10;import logging&#10;import re&#10;import hashlib&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;class TelegramNewsService:&#10;    &quot;&quot;&quot;Сервис для получения новостей из Telegram каналов и RSS источников&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Telegram каналы согласно ТЗ - ключевые источники по темам подарков, NFT и крипто&#10;        self.channels = [&#10;            # Каналы о подарках и бонусах&#10;            {'username': 'gift_newstg', 'name': 'Gift News TG', 'category': 'gifts'},&#10;            {'username': 'giftsutya', 'name': 'Gift Sutya', 'category': 'gifts'},&#10;            {'username': 'diruil_gifts', 'name': 'Diruil Gifts', 'category': 'gifts'},&#10;            {'username': 'giftnews', 'name': 'Gift News', 'category': 'gifts'},&#10;            {'username': 'BunnyStarsShop', 'name': 'Bunny Stars Shop', 'category': 'gifts'},&#10;            {'username': 'nft_podarki', 'name': 'NFT Подарки', 'category': 'gifts'},&#10;&#10;            # Технологии и инновации&#10;            {'username': 'westik', 'name': 'Westik', 'category': 'tech'},&#10;&#10;            # Сообщества и чаты&#10;            {'username': 'OHUENKOchat', 'name': 'OHUENKO Chat', 'category': 'community'},&#10;            {'username': 'community', 'name': 'Community', 'category': 'community'},&#10;            {'username': 'groza', 'name': 'Groza', 'category': 'community'},&#10;&#10;            # Криптовалюты и блокчейн&#10;            {'username': 'omicron', 'name': 'Omicron', 'category': 'crypto'},&#10;            {'username': 'tontopic_1', 'name': 'TON Topic', 'category': 'crypto'},&#10;            {'username': 'procryptodoping', 'name': 'Pro Crypto Doping', 'category': 'crypto'},&#10;&#10;            # NFT и цифровое искусство&#10;            {'username': 'nextgen_NFT', 'name': 'NextGen NFT', 'category': 'nft'},&#10;            {'username': 'snoopdogg', 'name': 'Snoop Dogg', 'category': 'nft'}&#10;        ]&#10;&#10;        # RSS источники согласно ТЗ - до 5 проверенных лент&#10;        self.rss_sources = [&#10;            {'url': 'https://vc.ru/rss', 'name': 'VC.ru', 'category': 'tech'},&#10;            {'url': 'https://forklog.com/feed/', 'name': 'ForkLog', 'category': 'crypto'},&#10;            {'url': 'https://www.coindesk.com/arc/outboundfeeds/rss/', 'name': 'CoinDesk', 'category': 'crypto'},&#10;            {'url': 'https://cointelegraph.com/rss', 'name': 'Cointelegraph', 'category': 'crypto'},&#10;            {'url': 'https://habr.com/ru/rss/hub/nft/all/', 'name': 'Habr NFT', 'category': 'nft'}&#10;        ]&#10;&#10;        self.cache = {}&#10;        self.cache_ttl = timedelta(minutes=30)  # Кэш на 30 минут согласно ТЗ&#10;&#10;        # Ключевые слова для категоризации согласно ТЗ&#10;        self.keywords = {&#10;            'gifts': [&#10;                'подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка',&#10;                'акция', 'розыгрыш', 'бонус', 'даром', 'гифт', 'gift', 'freebie',&#10;                'раздача', 'конкурс', 'приз', 'награда', 'cashback', 'кэшбек'&#10;            ],&#10;            'nft': [&#10;                'nft', 'нфт', 'токен', 'коллекция', 'мета', 'opensea', 'digital art',&#10;                'коллекционный', 'цифровое искусство', 'метавселенная', 'avatar',&#10;                'аватар', 'pfp', 'mint', 'минт', 'drop', 'дроп', 'rare', 'раритет'&#10;            ],&#10;            'crypto': [&#10;                'криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф',&#10;                'defi', 'торги', 'курс', 'btc', 'eth', 'usdt', 'binance', 'трейдинг',&#10;                'стейкинг', 'майнинг', 'altcoin', 'альткоин', 'pump', 'dump', 'hodl'&#10;            ],&#10;            'tech': [&#10;                'технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап',&#10;                'инновации', 'ai', 'ии', 'machine learning', 'блокчейн', 'веб3',&#10;                'app', 'приложение', 'software', 'hardware', 'gadget', 'гаджет'&#10;            ],&#10;            'community': [&#10;                'сообщество', 'чат', 'общение', 'форум', 'дискуссия', 'мнение',&#10;                'обсуждение', 'новости', 'анонс', 'встреча', 'event', 'мероприятие'&#10;            ]&#10;        }&#10;&#10;    def categorize_content(self, title: str, description: str = &quot;&quot;) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Автоматическая категоризация контента по ключевым словам согласно ТЗ&#10;        Приоритет: gifts &gt; crypto &gt; nft &gt; tech &gt; community&#10;        &quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        # Подсчитываем совпадения для каждой категории&#10;        category_scores = {}&#10;        for category, keywords in self.keywords.items():&#10;            score = sum(1 for keyword in keywords if keyword in content)&#10;            if score &gt; 0:&#10;                category_scores[category] = score&#10;&#10;        if not category_scores:&#10;            return 'general'&#10;&#10;        # Возвращаем категорию с наибольшим количеством совпадений&#10;        # При равенстве очков используем приоритет&#10;        priority = ['gifts', 'crypto', 'nft', 'tech', 'community']&#10;&#10;        max_score = max(category_scores.values())&#10;        best_categories = [cat for cat, score in category_scores.items() if score == max_score]&#10;&#10;        for priority_cat in priority:&#10;            if priority_cat in best_categories:&#10;                return priority_cat&#10;&#10;        return list(category_scores.keys())[0]  # Fallback&#10;&#10;    async def fetch_telegram_channel(self, channel_username: str) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получение новостей из Telegram канала через веб-скрапинг&#10;        Согласно ТЗ - интеграция с Telegram каналами для получения актуальных новостей&#10;        &quot;&quot;&quot;&#10;        try:&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == channel_username), None)&#10;            if not channel_data:&#10;                logger.warning(f&quot;Channel {channel_username} not found in configured channels&quot;)&#10;                return []&#10;&#10;            # Используем публичный API Telegram для получения постов&#10;            url = f&quot;https://t.me/s/{channel_username}&quot;&#10;&#10;            async with aiohttp.ClientSession() as session:&#10;                try:&#10;                    async with session.get(url, timeout=10) as response:&#10;                        if response.status == 200:&#10;                            html_content = await response.text()&#10;                            return self._parse_telegram_html(html_content, channel_data)&#10;                        else:&#10;                            logger.warning(f&quot;Failed to fetch {url}, status: {response.status}&quot;)&#10;                            return self._generate_mock_posts(channel_data)&#10;                except aiohttp.ClientTimeout:&#10;                    logger.warning(f&quot;Timeout fetching {url}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;                except Exception as e:&#10;                    logger.warning(f&quot;Error fetching {url}: {e}, using mock data&quot;)&#10;                    return self._generate_mock_posts(channel_data)&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in fetch_telegram_channel for {channel_username}: {e}&quot;)&#10;            return []&#10;&#10;    def _parse_telegram_html(self, html_content: str, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Парсинг HTML содержимого Telegram канала с поддержкой медиа&quot;&quot;&quot;&#10;        import re&#10;        from html import unescape&#10;&#10;        posts = []&#10;&#10;        # Простой парсер для получения постов из HTML&#10;        # В реальном проекте лучше использовать BeautifulSoup&#10;        post_pattern = r'&lt;div class=&quot;tgme_widget_message.*?&lt;/div&gt;\s*&lt;/div&gt;\s*&lt;/div&gt;'&#10;        text_pattern = r'&lt;div class=&quot;tgme_widget_message_text.*?&quot;.*?&gt;(.*?)&lt;/div&gt;'&#10;        date_pattern = r'&lt;time.*?datetime=&quot;([^&quot;]+)&quot;'&#10;        &#10;        # Паттерны для медиа контента&#10;        photo_pattern = r'&lt;a.*?class=&quot;tgme_widget_message_photo_wrap.*?style=&quot;background-image:url\(&amp;quot;([^&amp;]+)&amp;quot;\)&quot;'&#10;        video_pattern = r'&lt;video.*?src=&quot;([^&quot;]+)&quot;.*?poster=&quot;([^&quot;]*)&quot;.*?&gt;'&#10;        video_thumb_pattern = r'&lt;video.*?poster=&quot;([^&quot;]+)&quot;.*?&gt;'&#10;&#10;        post_matches = re.findall(post_pattern, html_content, re.DOTALL)&#10;&#10;        for i, post_html in enumerate(post_matches[:10]):  # Берем только первые 10 постов&#10;            # Извлекаем текст поста&#10;            text_match = re.search(text_pattern, post_html, re.DOTALL)&#10;            text = &quot;&quot;&#10;            if text_match:&#10;                text = unescape(re.sub(r'&lt;[^&gt;]+&gt;', '', text_match.group(1)))&#10;                text = text.strip()[:300] + &quot;...&quot; if len(text) &gt; 300 else text.strip()&#10;&#10;            # Извлекаем дату&#10;            date_match = re.search(date_pattern, post_html)&#10;            date = datetime.now().isoformat()&#10;            if date_match:&#10;                try:&#10;                    date = datetime.fromisoformat(date_match.group(1).replace('Z', '+00:00')).isoformat()&#10;                except:&#10;                    pass&#10;&#10;            # Извлекаем медиа контент&#10;            media = None&#10;            &#10;            # Проверяем на фото&#10;            photo_match = re.search(photo_pattern, post_html)&#10;            if photo_match:&#10;                photo_url = photo_match.group(1).replace('&amp;amp;', '&amp;')&#10;                media = {&#10;                    'type': 'photo',&#10;                    'url': photo_url,&#10;                    'thumbnail': photo_url,  # Для фото thumbnail = основное изображение&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;            &#10;            # Проверяем на видео&#10;            video_match = re.search(video_pattern, post_html)&#10;            if video_match:&#10;                video_url = video_match.group(1)&#10;                thumbnail_url = video_match.group(2) if len(video_match.groups()) &gt; 1 else None&#10;                media = {&#10;                    'type': 'video',&#10;                    'url': video_url,&#10;                    'thumbnail': thumbnail_url,&#10;                    'width': None,&#10;                    'height': None&#10;                }&#10;            elif not media:  # Если не нашли полное видео, ищем только thumbnail&#10;                video_thumb_match = re.search(video_thumb_pattern, post_html)&#10;                if video_thumb_match:&#10;                    media = {&#10;                        'type': 'video',&#10;                        'url': None,  # URL видео не найден&#10;                        'thumbnail': video_thumb_match.group(1),&#10;                        'width': None,&#10;                        'height': None&#10;                    }&#10;&#10;            if text:  # Только если удалось извлечь текст&#10;                # Генерируем заголовок из первых слов&#10;                title = text.split('.')[0][:100] if text else f&quot;Пост от {channel_data['name']}&quot;&#10;&#10;                post = {&#10;                    'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text[:50]}&quot;.encode()).hexdigest(),&#10;                    'title': title,&#10;                    'text': text,&#10;                    'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                    'date': date,&#10;                    'source': channel_data['name'],&#10;                    'category': channel_data['category'],&#10;                    'channel': channel_data['username'],&#10;                    'media': media  # Добавляем медиа данные&#10;                }&#10;&#10;                posts.append(post)&#10;&#10;        if not posts:  # Если парсинг не удался, используем мок данные&#10;            return self._generate_mock_posts(channel_data)&#10;&#10;        return posts&#10;&#10;    def _generate_mock_posts(self, channel_data: Dict) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Генерация мок данных для канала согласно ТЗ&quot;&quot;&quot;&#10;        posts = []&#10;        base_time = datetime.now()&#10;&#10;        # Контент в зависимости от категории канала&#10;        content_templates = {&#10;            'gifts': [&#10;                &quot; Новые бесплатные подарки! Успейте получить эксклюзивные бонусы&quot;,&#10;                &quot; Промокоды на скидки до 70%! Ограниченное предложение&quot;,&#10;                &quot; Розыгрыш ценных призов среди подписчиков канала&quot;,&#10;                &quot;️ Лучшие предложения дня - не пропустите!&quot;&#10;            ],&#10;            'crypto': [&#10;                &quot; Анализ рынка: Bitcoin показывает рост на 5%&quot;,&#10;                &quot; Новые возможности DeFi инвестиций - обзор проектов&quot;,&#10;                &quot; Перспективные альткоины для долгосрочных инвестиций&quot;,&#10;                &quot;⚡ Срочные новости: крупные движения на криптовалютном рынке&quot;&#10;            ],&#10;            'nft': [&#10;                &quot;️ Новая коллекция NFT от известного художника уже в продаже&quot;,&#10;                &quot; Раритетные токены на аукционе - последний шанс приобрести&quot;,&#10;                &quot; Обзор лучших NFT художников недели&quot;,&#10;                &quot; Статистика NFT рынка: рост объемов торгов на 15%&quot;&#10;            ],&#10;            'tech': [&#10;                &quot; Революционные технологии 2025 года - что нас ждет&quot;,&#10;                &quot; Обзор новейших гаджетов от мировых производителей&quot;,&#10;                &quot; Стартапы в сфере ИИ привлекли рекордные инвестиции&quot;,&#10;                &quot; ТОП мобильных приложений для повышения продуктивности&quot;&#10;            ],&#10;            'community': [&#10;                &quot; Обсуждение актуальных тем в нашем сообществе&quot;,&#10;                &quot; Важные новости и обновления для участников&quot;,&#10;                &quot; Анонс предстоящих мероприятий и встреч&quot;,&#10;                &quot; Полезные советы и рекомендации от экспертов&quot;&#10;            ]&#10;        }&#10;&#10;        templates = content_templates.get(channel_data['category'], content_templates['community'])&#10;&#10;        for i in range(5):  # Генерируем 5 постов&#10;            post_time = base_time - timedelta(hours=i * 4 + hash(channel_data['username']) % 12)&#10;&#10;            text = templates[i % len(templates)]&#10;            title = text.split('.')[0][:80] + (&quot;...&quot; if len(text.split('.')[0]) &gt; 80 else &quot;&quot;)&#10;&#10;            posts.append({&#10;                'id': hashlib.md5(f&quot;{channel_data['username']}_{i}_{text}&quot;.encode()).hexdigest(),&#10;                'title': title,&#10;                'text': text,&#10;                'link': f&quot;https://t.me/{channel_data['username']}&quot;,&#10;                'date': post_time.isoformat(),&#10;                'source': channel_data['name'],&#10;                'category': channel_data['category'],&#10;                'channel': channel_data['username']&#10;            })&#10;&#10;        return posts&#10;        &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;        content = (title + &quot; &quot; + description).lower()&#10;&#10;        for category, keywords in self.keywords.items():&#10;            if any(keyword in content for keyword in keywords):&#10;                return category&#10;&#10;        return 'general'&#10;&#10;    async def fetch_rss_feed(self, source: Dict[str, str]) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получение новостей из RSS источника&quot;&quot;&quot;&#10;        try:&#10;            # Используем feedparser для парсинга RSS&#10;            feed = feedparser.parse(source['url'])&#10;&#10;            if not feed.entries:&#10;                logger.warning(f&quot;No entries found in RSS feed: {source['url']}&quot;)&#10;                return []&#10;&#10;            articles = []&#10;            for entry in feed.entries[:10]:  # Берем только последние 10 новостей&#10;                # Получаем описание из различных полей&#10;                description = &quot;&quot;&#10;                if hasattr(entry, 'summary'):&#10;                    description = entry.summary&#10;                elif hasattr(entry, 'description'):&#10;                    description = entry.description&#10;                elif hasattr(entry, 'content'):&#10;                    description = entry.content[0].value if entry.content else &quot;&quot;&#10;&#10;                # Очищаем HTML теги&#10;                description = re.sub(r'&lt;[^&gt;]+&gt;', '', description)&#10;                description = description[:200] + &quot;...&quot; if len(description) &gt; 200 else description&#10;&#10;                # Получаем дату публикации&#10;                pub_date = datetime.now()&#10;                if hasattr(entry, 'published_parsed') and entry.published_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.published_parsed))&#10;                elif hasattr(entry, 'updated_parsed') and entry.updated_parsed:&#10;                    import time&#10;                    pub_date = datetime.fromtimestamp(time.mktime(entry.updated_parsed))&#10;&#10;                # Автоматическая категоризация&#10;                auto_category = self.categorize_content(entry.title, description)&#10;                final_category = source.get('category', auto_category)&#10;&#10;                article = {&#10;                    'id': hashlib.md5((entry.link + entry.title).encode()).hexdigest(),&#10;                    'title': entry.title,&#10;                    'text': description,&#10;                    'link': entry.link,&#10;                    'date': pub_date.isoformat(),&#10;                    'source': source['name'],&#10;                    'category': final_category,&#10;                    'channel': 'rss_' + source['name'].lower().replace(' ', '_')&#10;                }&#10;&#10;                articles.append(article)&#10;&#10;            return articles&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error fetching RSS feed {source['url']}: {e}&quot;)&#10;            return []&#10;        &quot;&quot;&quot;Получить информацию о канале через Telegram API&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока возвращаем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return None&#10;&#10;            return {&#10;                'username': username,&#10;                'title': channel_data['name'],&#10;                'description': f&quot;Канал {channel_data['name']} - {channel_data['category']}&quot;,&#10;                'subscribers_count': 1000 + hash(username) % 50000,  # Мок количества подписчиков&#10;                'category': channel_data['category']&#10;            }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channel info for {username}: {e}&quot;)&#10;            return None&#10;&#10;    async def get_channel_posts(self, username: str, limit: int = 10) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить последние посты из канала&quot;&quot;&quot;&#10;        try:&#10;            # В реальной реализации здесь будет вызов к Telegram Bot API&#10;            # Пока генерируем мок данные&#10;            channel_data = next((ch for ch in self.channels if ch['username'] == username), None)&#10;            if not channel_data:&#10;                return []&#10;&#10;            posts = []&#10;            base_time = datetime.now()&#10;&#10;            for i in range(limit):&#10;                post_time = base_time - timedelta(hours=i * 2 + hash(username + str(i)) % 24)&#10;&#10;                # Генерируем контент на основе категории&#10;                if channel_data['category'] == 'gifts':&#10;                    titles = [&#10;                        f&quot; Новые бесплатные подарки в {channel_data['name']}!&quot;,&#10;                        f&quot; Эксклюзивные промокоды и скидки&quot;,&#10;                        f&quot; Розыгрыш призов для подписчиков&quot;,&#10;                        f&quot;️ Лучшие предложения дня&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'crypto':&#10;                    titles = [&#10;                        f&quot; Анализ рынка криптовалют&quot;,&#10;                        f&quot; Новые возможности для инвестиций&quot;,&#10;                        f&quot; Обзор перспективных проектов&quot;,&#10;                        f&quot;⚡ Быстрые новости из мира крипто&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'nft':&#10;                    titles = [&#10;                        f&quot;️ Новые NFT коллекции&quot;,&#10;                        f&quot; Раритетные токены на аукционе&quot;,&#10;                        f&quot; Обзор NFT художников&quot;,&#10;                        f&quot; Статистика NFT рынка&quot;&#10;                    ]&#10;                elif channel_data['category'] == 'tech':&#10;                    titles = [&#10;                        f&quot; Новости технологий&quot;,&#10;                        f&quot; Обзор гаджетов&quot;,&#10;                        f&quot; Инновации в IT&quot;,&#10;                        f&quot; Мобильные приложения&quot;&#10;                    ]&#10;                else:&#10;                    titles = [&#10;                        f&quot; Новости от {channel_data['name']}&quot;,&#10;                        f&quot;ℹ️ Важные обновления&quot;,&#10;                        f&quot; Полезная информация&quot;,&#10;                        f&quot; Горячие темы&quot;&#10;                    ]&#10;&#10;                title = titles[i % len(titles)]&#10;&#10;                posts.append({&#10;                    'id': f&quot;{username}_{i}&quot;,&#10;                    'title': title,&#10;                    'text': f&quot;Интересный контент от канала {channel_data['name']}. Подписывайтесь для получения актуальных новостей!&quot;,&#10;                    'date': post_time.isoformat(),&#10;                    'views': 100 + hash(username + str(i)) % 5000,&#10;                    'link': f&quot;https://t.me/{username}&quot;,&#10;                    'channel': username,&#10;                    'category': channel_data['category']&#10;                })&#10;&#10;            return posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting posts for {username}: {e}&quot;)&#10;            return []&#10;&#10;    async def get_all_news(self, category: str = 'all', limit: int = 50) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;&#10;        Получить новости из всех источников согласно ТЗ:&#10;        - Telegram каналы (основные источники)&#10;        - RSS ленты (дополнительные источники)&#10;        - Автоматическая категоризация и дедупликация&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Проверяем кэш&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, cached_time = self.cache[cache_key]&#10;                if datetime.now() - cached_time &lt; self.cache_ttl:&#10;                    logger.info(f&quot;Returning cached news for {category}, {len(cached_data)} items&quot;)&#10;                    return cached_data&#10;&#10;            all_posts = []&#10;&#10;            # 1. Получаем данные из Telegram каналов (приоритетный источник согласно ТЗ)&#10;            telegram_channels = self.channels&#10;            if category != 'all':&#10;                telegram_channels = [ch for ch in self.channels if ch['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(telegram_channels)} Telegram channels&quot;)&#10;&#10;            # Получаем посты из Telegram каналов&#10;            telegram_tasks = []&#10;            for channel in telegram_channels:&#10;                telegram_tasks.append(self.fetch_telegram_channel(channel['username']))&#10;&#10;            telegram_results = await asyncio.gather(*telegram_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(telegram_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} posts from {telegram_channels[i]['username']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching posts from {telegram_channels[i]['username']}: {result}&quot;)&#10;&#10;            # 2. Получаем данные из RSS источников (дополнительный источник)&#10;            rss_sources = self.rss_sources&#10;            if category != 'all':&#10;                rss_sources = [src for src in self.rss_sources if src['category'] == category]&#10;&#10;            logger.info(f&quot;Fetching from {len(rss_sources)} RSS sources&quot;)&#10;&#10;            # Получаем статьи из RSS&#10;            rss_tasks = []&#10;            for source in rss_sources:&#10;                rss_tasks.append(self.fetch_rss_feed(source))&#10;&#10;            rss_results = await asyncio.gather(*rss_tasks, return_exceptions=True)&#10;&#10;            for i, result in enumerate(rss_results):&#10;                if isinstance(result, list):&#10;                    all_posts.extend(result)&#10;                    logger.info(f&quot;Got {len(result)} articles from {rss_sources[i]['name']}&quot;)&#10;                else:&#10;                    logger.error(f&quot;Error fetching RSS from {rss_sources[i]['url']}: {result}&quot;)&#10;&#10;            # 3. Обработка и дедупликация согласно ТЗ&#10;            # Удаляем дубликаты по заголовку и ссылке&#10;            seen = set()&#10;            unique_posts = []&#10;            for post in all_posts:&#10;                # Создаем ключ для дедупликации&#10;                title_clean = re.sub(r'[^\w\s]', '', post['title'].lower()).strip()&#10;                key = (title_clean, post.get('link', ''))&#10;                if key not in seen:&#10;                    seen.add(key)&#10;                    unique_posts.append(post)&#10;&#10;            logger.info(f&quot;After deduplication: {len(unique_posts)} unique posts from {len(all_posts)} total&quot;)&#10;&#10;            # 4. Сортировка по дате (новые сначала)&#10;            try:&#10;                unique_posts.sort(&#10;                    key=lambda x: datetime.fromisoformat(x['date'].replace('Z', '+00:00')),&#10;                    reverse=True&#10;                )&#10;            except Exception as e:&#10;                logger.warning(f&quot;Error sorting by date: {e}, using original order&quot;)&#10;&#10;            # 5. Ограничиваем количество согласно ТЗ&#10;            final_posts = unique_posts[:limit]&#10;&#10;            # 6. Сохраняем в кэш на 30 минут согласно ТЗ&#10;            self.cache[cache_key] = (final_posts, datetime.now())&#10;&#10;            logger.info(f&quot;Returning {len(final_posts)} news items for category '{category}'&quot;)&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error in get_all_news: {e}&quot;)&#10;            # В случае ошибки возвращаем данные из кэша, если есть&#10;            cache_key = f&quot;news_{category}_{limit}&quot;&#10;            if cache_key in self.cache:&#10;                cached_data, _ = self.cache[cache_key]&#10;                logger.info(&quot;Returning stale cached data due to error&quot;)&#10;                return cached_data&#10;            return []&#10;&#10;            return final_posts&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting all news: {e}&quot;)&#10;            return []&#10;&#10;    async def get_channels_info(self) -&gt; List[Dict[str, Any]]:&#10;        &quot;&quot;&quot;Получить информацию о всех каналах&quot;&quot;&quot;&#10;        try:&#10;            tasks = []&#10;            for channel in self.channels:&#10;                tasks.append(self.get_channel_info(channel['username']))&#10;&#10;            results = await asyncio.gather(*tasks, return_exceptions=True)&#10;&#10;            channels_info = []&#10;            for result in results:&#10;                if isinstance(result, dict):&#10;                    channels_info.append(result)&#10;&#10;            return channels_info&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Error getting channels info: {e}&quot;)&#10;            return []&#10;&#10;&#10;# Глобальный экземпляр сервиса&#10;telegram_news_service = TelegramNewsService()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>