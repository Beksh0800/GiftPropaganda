<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile.render">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile.render" />
              <option name="originalContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;USER appuser&#10;COPY .env ./&#10;&#10;# Создаем пользователя для безопасности&#10;RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app&#10;# Команда запуска&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;" />
              <option name="updatedContent" value="# Production Dockerfile для Render&#10;FROM python:3.12-slim&#10;&#10;# Устанавливаем системные зависимости&#10;RUN apt-get update &amp;&amp; apt-get install -y \&#10;    gcc \&#10;    &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Копируем requirements и устанавливаем зависимости&#10;COPY requirements.txt .&#10;RUN pip install --no-cache-dir -r requirements.txt&#10;&#10;# Копируем код приложения&#10;COPY server/ ./server/&#10;&#10;# Экспонируем порт&#10;EXPOSE 8000&#10;&#10;# Команда запуска (переменные окружения будут переданы Render)&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  source?: {&#10;    name: string;&#10;    type: string;&#10;  };&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000 // 10 секунд таймаут&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;&#10;    // Возвращаем более детальную информацию об ошибке&#10;    let errorMessage = 'Ошибка загрузки новостей';&#10;    if (error.response) {&#10;      errorMessage = `Ошибка сервера: ${error.response.status}`;&#10;    } else if (error.request) {&#10;      errorMessage = 'Нет ответа от сервера';&#10;    }&#10;&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: errorMessage&#10;    };&#10;  }&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;// Определяем API URL в зависимости от окружения&#10;const API_URL = process.env.NODE_ENV === 'production'&#10;  ? 'https://giftpropaganda.onrender.com/api/news/'&#10;  : 'http://localhost:8000/api/news/';&#10;&#10;export interface MediaItem {&#10;  type: 'photo' | 'video';&#10;  url: string;&#10;  thumbnail?: string;&#10;  width?: number;&#10;  height?: number;&#10;  duration?: number; // Для видео&#10;  size?: number; // Размер файла&#10;}&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;  image_url?: string; // Основное изображение&#10;  video_url?: string; // Основное видео&#10;  reading_time?: number;&#10;  views_count?: number;&#10;  author?: string;&#10;  subtitle?: string;&#10;  media?: MediaItem; // Дополнительное медиа&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;  total?: number;&#10;  page?: number;&#10;  limit?: number;&#10;}&#10;&#10;export const fetchNews = async (category?: string): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const url = category ? `${API_URL}?category=${category}` : API_URL;&#10;&#10;    const response = await axios.get&lt;NewsResponse&gt;(url, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 15000 // Увеличиваем таймаут до 15 секунд&#10;    });&#10;&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    &#10;    if (error.response) {&#10;      throw new Error(`Ошибка сервера: ${error.response.status} ${error.response.statusText}`);&#10;    } else if (error.request) {&#10;      throw new Error('Нет ответа от сервера. Проверьте подключение к интернету.');&#10;    } else {&#10;      throw new Error(`Ошибка запроса: ${error.message}`);&#10;    }&#10;  }&#10;};&#10;&#10;export const fetchNewsById = async (id: number): Promise&lt;NewsItem&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsItem&gt;(`${API_URL}${id}`, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000&#10;    });&#10;&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новости:', error);&#10;    throw new Error('Не удалось загрузить новость');&#10;  }&#10;};&#10;&#10;export const fetchCategories = async (): Promise&lt;string[]&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;{status: string, data: string[]}&gt;(`${API_URL}categories/`, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true',&#10;        'Content-Type': 'application/json',&#10;        'Accept': 'application/json'&#10;      },&#10;      timeout: 10000&#10;    });&#10;&#10;    return response.data.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке категорий:', error);&#10;    return ['gifts', 'crypto', 'tech', 'community', 'gaming']; // fallback&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/TelegramWebApp.ts" />
              <option name="updatedContent" value="// Telegram WebApp API для React&#10;class TelegramWebApp {&#10;  private webApp: any = null;&#10;&#10;  init() {&#10;    // Проверяем, что мы внутри Telegram&#10;    if (typeof window !== 'undefined' &amp;&amp; window.Telegram?.WebApp) {&#10;      this.webApp = window.Telegram.WebApp;&#10;      this.webApp.ready();&#10;      this.webApp.expand();&#10;&#10;      // Настройка темы&#10;      this.webApp.setHeaderColor('#1a1a1a');&#10;      this.webApp.setBackgroundColor('#1a1a1a');&#10;&#10;      console.log('Telegram WebApp инициализирован');&#10;    } else {&#10;      console.log('Telegram WebApp недоступен - работаем в браузере');&#10;    }&#10;  }&#10;&#10;  isAvailable(): boolean {&#10;    return this.webApp !== null;&#10;  }&#10;&#10;  expand() {&#10;    if (this.webApp &amp;&amp; this.webApp.expand) {&#10;      this.webApp.expand();&#10;    }&#10;  }&#10;&#10;  getThemeParams() {&#10;    if (this.webApp) {&#10;      return this.webApp.themeParams;&#10;    }&#10;    return {&#10;      bg_color: '#1a1a1a',&#10;      text_color: '#ffffff',&#10;      hint_color: '#999999',&#10;      link_color: '#0088cc',&#10;      button_color: '#0088cc',&#10;      button_text_color: '#ffffff'&#10;    };&#10;  }&#10;&#10;  getUserData() {&#10;    if (this.webApp &amp;&amp; this.webApp.initDataUnsafe) {&#10;      return this.webApp.initDataUnsafe.user;&#10;    }&#10;    return null;&#10;  }&#10;&#10;  triggerHapticFeedback(type: 'impact' | 'notification' = 'impact') {&#10;    if (this.webApp &amp;&amp; this.webApp.HapticFeedback) {&#10;      if (type === 'impact') {&#10;        this.webApp.HapticFeedback.impactOccurred('light');&#10;      } else if (type === 'notification') {&#10;        this.webApp.HapticFeedback.notificationOccurred('success');&#10;      }&#10;    }&#10;  }&#10;&#10;  showPopup(title: string, message: string, buttons?: any[]) {&#10;    if (this.webApp &amp;&amp; this.webApp.showPopup) {&#10;      return this.webApp.showPopup({&#10;        title,&#10;        message,&#10;        buttons: buttons || [{ type: 'ok' }]&#10;      });&#10;    }&#10;  }&#10;&#10;  close() {&#10;    if (this.webApp &amp;&amp; this.webApp.close) {&#10;      this.webApp.close();&#10;    }&#10;  }&#10;&#10;  openLink(url: string) {&#10;    if (this.webApp &amp;&amp; this.webApp.openLink) {&#10;      this.webApp.openLink(url);&#10;    } else {&#10;      window.open(url, '_blank');&#10;    }&#10;  }&#10;&#10;  setMainButton(text: string, callback?: () =&gt; void) {&#10;    if (this.webApp &amp;&amp; this.webApp.MainButton) {&#10;      this.webApp.MainButton.text = text;&#10;      this.webApp.MainButton.show();&#10;      &#10;      if (callback) {&#10;        this.webApp.MainButton.onClick(callback);&#10;      }&#10;    }&#10;  }&#10;&#10;  hideMainButton() {&#10;    if (this.webApp &amp;&amp; this.webApp.MainButton) {&#10;      this.webApp.MainButton.hide();&#10;    }&#10;  }&#10;}&#10;&#10;// Создаем единственный экземпляр&#10;const telegramWebApp = new TelegramWebApp();&#10;&#10;export default telegramWebApp;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/telegram/telegram-webapp.d.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// Типы для Telegram WebApp API&#13;&#10;declare global {&#13;&#10;  interface Window {&#13;&#10;    Telegram?: {&#13;&#10;      WebApp: {&#13;&#10;        ready(): void;&#13;&#10;        expand(): void;&#13;&#10;        close(): void;&#13;&#10;        setHeaderColor(color: string): void;&#13;&#10;        setBackgroundColor(color: string): void;&#13;&#10;        showAlert(message: string): void;&#13;&#10;        showConfirm(message: string, callback: (confirmed: boolean) =&gt; void): void;&#13;&#10;        openLink(url: string): void;&#13;&#10;        onEvent(eventType: string, callback: () =&gt; void): void;&#13;&#10;        offEvent(eventType: string, callback: () =&gt; void): void;&#13;&#10;        isExpanded: boolean;&#13;&#10;        viewportHeight: number;&#13;&#10;        themeParams: {&#13;&#10;          bg_color?: string;&#13;&#10;          text_color?: string;&#13;&#10;          hint_color?: string;&#13;&#10;          link_color?: string;&#13;&#10;          button_color?: string;&#13;&#10;          button_text_color?: string;&#13;&#10;          secondary_bg_color?: string;&#13;&#10;          destructive_text_color?: string;&#13;&#10;        };&#13;&#10;        initDataUnsafe?: {&#13;&#10;          user?: {&#13;&#10;            id: number;&#13;&#10;            first_name: string;&#13;&#10;            last_name?: string;&#13;&#10;            username?: string;&#13;&#10;            language_code?: string;&#13;&#10;          };&#13;&#10;        };&#13;&#10;        HapticFeedback?: {&#13;&#10;          impactOccurred(style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft'): void;&#13;&#10;          notificationOccurred(type: 'error' | 'success' | 'warning'): void;&#13;&#10;          selectionChanged(): void;&#13;&#10;        };&#13;&#10;        initData: string;&#13;&#10;        version: string;&#13;&#10;        platform: string;&#13;&#10;        colorScheme: 'light' | 'dark';&#13;&#10;        isClosingConfirmationEnabled: boolean;&#13;&#10;        sendData(data: string): void;&#13;&#10;        openTelegramLink(url: string): void;&#13;&#10;        openInvoice(url: string, callback?: (status: string) =&gt; void): void;&#13;&#10;        showPopup(params: {&#13;&#10;          title?: string;&#13;&#10;          message: string;&#13;&#10;          buttons?: Array&lt;{&#13;&#10;            id?: string;&#13;&#10;            type?: 'default' | 'ok' | 'close' | 'cancel' | 'destructive';&#13;&#10;            text: string;&#13;&#10;          }&gt;;&#13;&#10;        }, callback?: (buttonId: string) =&gt; void): void;&#13;&#10;        showScanQrPopup(params: { text?: string }, callback?: (text: string) =&gt; void): void;&#13;&#10;        closeScanQrPopup(): void;&#13;&#10;        readTextFromClipboard(callback?: (text: string) =&gt; void): void;&#13;&#10;        requestWriteAccess(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        requestContact(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        requestLocation(callback?: (granted: boolean) =&gt; void): void;&#13;&#10;        isVersionAtLeast(version: string): boolean;&#13;&#10;        BackButton: {&#13;&#10;          isVisible: boolean;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;        };&#13;&#10;        MainButton: {&#13;&#10;          text: string;&#13;&#10;          color: string;&#13;&#10;          textColor: string;&#13;&#10;          isVisible: boolean;&#13;&#10;          isActive: boolean;&#13;&#10;          isProgressVisible: boolean;&#13;&#10;          setText(text: string): void;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;          enable(): void;&#13;&#10;          disable(): void;&#13;&#10;          showProgress(leaveActive?: boolean): void;&#13;&#10;          hideProgress(): void;&#13;&#10;          setParams(params: {&#13;&#10;            text?: string;&#13;&#10;            color?: string;&#13;&#10;            text_color?: string;&#13;&#10;            is_active?: boolean;&#13;&#10;            is_visible?: boolean;&#13;&#10;          }): void;&#13;&#10;        };&#13;&#10;        SettingsButton: {&#13;&#10;          isVisible: boolean;&#13;&#10;          onClick(callback: () =&gt; void): void;&#13;&#10;          offClick(callback: () =&gt; void): void;&#13;&#10;          show(): void;&#13;&#10;          hide(): void;&#13;&#10;        };&#13;&#10;      };&#13;&#10;    };&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;export {};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/001_add_media_fields.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/001_add_media_fields.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;add_media_fields_to_news_items&#10;&#10;Revision ID: 001&#10;Revises: &#10;Create Date: 2025-07-26 02:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;&#10;# revision identifiers&#10;revision = '001'&#10;down_revision = None&#10;branch_labels = None&#10;depends_on = None&#10;&#10;def upgrade():&#10;    # Добавляем новые поля в таблицу news_items&#10;    op.add_column('news_items', sa.Column('image_url', sa.String(1000), nullable=True))&#10;    op.add_column('news_items', sa.Column('video_url', sa.String(1000), nullable=True))&#10;    op.add_column('news_items', sa.Column('reading_time', sa.Integer(), nullable=True))&#10;    op.add_column('news_items', sa.Column('views_count', sa.Integer(), nullable=True))&#10;    op.add_column('news_items', sa.Column('author', sa.String(200), nullable=True))&#10;    op.add_column('news_items', sa.Column('subtitle', sa.String(500), nullable=True))&#10;&#10;def downgrade():&#10;    # Удаляем добавленные поля&#10;    op.drop_column('news_items', 'subtitle')&#10;    op.drop_column('news_items', 'author')&#10;    op.drop_column('news_items', 'views_count')&#10;    op.drop_column('news_items', 'reading_time')&#10;    op.drop_column('news_items', 'video_url')&#10;    op.drop_column('news_items', 'image_url')" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/.env" />
              <option name="updatedContent" value="# База данных&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=your_bot_token_here&#10;WEBHOOK_URL=https://your-domain.com/telegram_webhook&#10;&#10;# Redis (опционально)&#10;REDIS_URL=redis://localhost:6379&#10;&#10;# Другие настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/__init__.py" />
              <option name="updatedContent" value="# API package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models.py" />
              <option name="updatedContent" value="from pydantic import BaseModel&#10;from typing import List, Optional&#10;from datetime import datetime&#10;&#10;class NewsItemResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    content: str&#10;    link: str&#10;    publish_date: str&#10;    category: str&#10;    image_url: Optional[str] = None&#10;    video_url: Optional[str] = None&#10;    reading_time: Optional[int] = None&#10;    views_count: Optional[int] = 0&#10;    author: Optional[str] = None&#10;    subtitle: Optional[str] = None&#10;&#10;    class Config:&#10;        from_attributes = True&#10;&#10;class NewsResponse(BaseModel):&#10;    data: List[NewsItemResponse]&#10;    total: int&#10;    page: int&#10;    pages: int&#10;&#10;class CategoryResponse(BaseModel):&#10;    categories: List[str]&#10;&#10;class StatsResponse(BaseModel):&#10;    total_news: int&#10;    categories: dict&#10;    last_updated: str" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/rss.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/rss.py" />
              <option name="updatedContent" value="import feedparser&#10;import logging&#10;from sqlalchemy.orm import Session&#10;from typing import List, Dict, Any&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;async def fetch_rss_feeds(session: Session) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Получение новостей из RSS источников&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Fetching RSS feeds...&quot;)&#10;        &#10;        # Список RSS источников&#10;        rss_sources = [&#10;            {&quot;url&quot;: &quot;https://vc.ru/rss&quot;, &quot;name&quot;: &quot;VC.ru&quot;, &quot;category&quot;: &quot;tech&quot;},&#10;            {&quot;url&quot;: &quot;https://forklog.com/feed/&quot;, &quot;name&quot;: &quot;ForkLog&quot;, &quot;category&quot;: &quot;crypto&quot;}&#10;        ]&#10;        &#10;        articles = []&#10;        for source in rss_sources:&#10;            try:&#10;                feed = feedparser.parse(source[&quot;url&quot;])&#10;                for entry in feed.entries[:5]:  # Берем только 5 последних&#10;                    article = {&#10;                        &quot;title&quot;: entry.title,&#10;                        &quot;link&quot;: entry.link,&#10;                        &quot;description&quot;: getattr(entry, 'summary', ''),&#10;                        &quot;source&quot;: source[&quot;name&quot;],&#10;                        &quot;category&quot;: source[&quot;category&quot;]&#10;                    }&#10;                    articles.append(article)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error parsing RSS {source['url']}: {e}&quot;)&#10;        &#10;        logger.info(f&quot;RSS feeds fetched successfully, {len(articles)} articles&quot;)&#10;        return articles&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Error fetching RSS feeds: {e}&quot;)&#10;        return []" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>