<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM python:3.12&#10;WORKDIR /app&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]&#10;RUN pip install fastapi uvicorn sqlalchemy psycopg2-binary feedparser requests apscheduler aiohttp&#10;" />
              <option name="updatedContent" value="FROM python:3.12&#10;WORKDIR /app&#10;COPY requirements.txt .&#10;RUN pip install -r requirements.txt&#10;COPY . .&#10;CMD [&quot;uvicorn&quot;, &quot;server.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/App.tsx" />
              <option name="originalContent" value="import React, { useState, useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;&#10;const AppContainer = styled.div`&#10;  background-color: #f5f5f5;&#10;  min-height: 100vh;&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;&#10;  color: #333;&#10;  padding: 20px;&#10;`;&#10;&#10;const Header = styled.header`&#10;  background-color: #0088cc;&#10;  color: white;&#10;  padding: 15px;&#10;  text-align: center;&#10;  border-radius: 10px 10px 0 0;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;`;&#10;&#10;const NewsList = styled.ul`&#10;  list-style: none;&#10;  padding: 0;&#10;  margin: 20px 0;&#10;`;&#10;&#10;const NewsItemCard = styled.li`&#10;  background-color: white;&#10;  padding: 15px;&#10;  margin-bottom: 10px;&#10;  border-radius: 10px;&#10;  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);&#10;  transition: transform 0.2s;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-2px);&#10;  }&#10;`;&#10;&#10;const Title = styled.h2`&#10;  color: #0088cc;&#10;  margin: 0 0 10px;&#10;  font-size: 1.2em;&#10;`;&#10;&#10;const Content = styled.p`&#10;  color: #666;&#10;  margin: 5px 0;&#10;  font-size: 0.9em;&#10;`;&#10;&#10;const Link = styled.a`&#10;  color: #0088cc;&#10;  text-decoration: none;&#10;  font-weight: bold;&#10;&#10;  &amp;:hover {&#10;    text-decoration: underline;&#10;  }&#10;`;&#10;&#10;const CategoryDate = styled.p`&#10;  color: #999;&#10;  font-size: 0.8em;&#10;  margin: 5px 0 0;&#10;`;&#10;&#10;const Message = styled.p`&#10;  text-align: center;&#10;  color: #666;&#10;`;&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsResponse&gt;({ status: 'success', data: [], message: '' });&#10;&#10;  useEffect(() =&gt; {&#10;    const getNews = async () =&gt; {&#10;      const data = await fetchNews();&#10;      setNews(data);&#10;    };&#10;    getNews();&#10;    const interval = setInterval(getNews, 60000); // Обновление каждую минуту&#10;    return () =&gt; clearInterval(interval); // Очистка при размонтировании&#10;  }, []);&#10;&#10;  return (&#10;    &lt;AppContainer&gt;&#10;      &lt;Header&gt;&#10;        &lt;h1&gt;Новости от Telegram&lt;/h1&gt;&#10;      &lt;/Header&gt;&#10;      {news.status === 'success' ? (&#10;        news.data.length &gt; 0 ? (&#10;          &lt;NewsList&gt;&#10;            {news.data.map((item: NewsItem) =&gt; (&#10;              &lt;NewsItemCard key={item.id}&gt;&#10;                &lt;Title&gt;{item.title}&lt;/Title&gt;&#10;                &lt;Content&gt;{item.content}&lt;/Content&gt;&#10;                &lt;Link href={item.link} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#10;                  Читать полностью&#10;                &lt;/Link&gt;&#10;                &lt;CategoryDate&gt;&#10;                  Категория: {item.category} | Дата: {new Date(item.publish_date).toLocaleDateString()}&#10;                &lt;/CategoryDate&gt;&#10;              &lt;/NewsItemCard&gt;&#10;            ))}&#10;          &lt;/NewsList&gt;&#10;        ) : (&#10;          &lt;Message&gt;{news.message}&lt;/Message&gt;&#10;        )&#10;      ) : (&#10;        &lt;Message&gt;Ошибка загрузки новостей&lt;/Message&gt;&#10;      )}&#10;    &lt;/AppContainer&gt;&#10;  );&#10;};&#10;&#10;export default App;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import styled from 'styled-components';&#10;import { fetchNews, NewsResponse, NewsItem } from './api/news';&#10;&#10;const AppContainer = styled.div`&#10;  background-color: #f5f5f5;&#10;  min-height: 100vh;&#10;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;&#10;  color: #333;&#10;  padding: 20px;&#10;`;&#10;&#10;const Header = styled.header`&#10;  background-color: #0088cc;&#10;  color: white;&#10;  padding: 15px;&#10;  text-align: center;&#10;  border-radius: 10px 10px 0 0;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;`;&#10;&#10;const NewsList = styled.ul`&#10;  list-style: none;&#10;  padding: 0;&#10;  margin: 20px 0;&#10;`;&#10;&#10;const NewsItemCard = styled.li`&#10;  background-color: white;&#10;  padding: 15px;&#10;  margin-bottom: 10px;&#10;  border-radius: 10px;&#10;  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);&#10;  transition: transform 0.2s;&#10;&#10;  &amp;:hover {&#10;    transform: translateY(-2px);&#10;  }&#10;`;&#10;&#10;const Title = styled.h2`&#10;  color: #0088cc;&#10;  margin: 0 0 10px;&#10;  font-size: 1.2em;&#10;`;&#10;&#10;const Content = styled.p`&#10;  color: #666;&#10;  margin: 5px 0;&#10;  font-size: 0.9em;&#10;`;&#10;&#10;const SourceLink = styled.a`&#10;  color: #bbb;&#10;  font-size: 0.75em;&#10;  display: block;&#10;  margin-top: 10px;&#10;  text-decoration: none;&#10;  word-break: break-all;&#10;&#10;  &amp;:hover {&#10;    text-decoration: underline;&#10;    color: #888;&#10;  }&#10;`;&#10;&#10;const CategoryDate = styled.p`&#10;  color: #999;&#10;  font-size: 0.8em;&#10;  margin: 5px 0 0;&#10;`;&#10;&#10;const Message = styled.p`&#10;  text-align: center;&#10;  color: #666;&#10;`;&#10;&#10;const App: React.FC = () =&gt; {&#10;  const [news, setNews] = useState&lt;NewsResponse&gt;({ status: 'success', data: [], message: '' });&#10;&#10;  useEffect(() =&gt; {&#10;    const getNews = async () =&gt; {&#10;      const data = await fetchNews();&#10;      setNews(data);&#10;    };&#10;    getNews();&#10;    const interval = setInterval(getNews, 60000); // Обновление каждую минуту&#10;    return () =&gt; clearInterval(interval); // Очистка при размонтировании&#10;  }, []);&#10;&#10;  return (&#10;    &lt;AppContainer&gt;&#10;      &lt;Header&gt;&#10;        &lt;h1&gt;Новости от Telegram&lt;/h1&gt;&#10;      &lt;/Header&gt;&#10;      {news.status === 'success' ? (&#10;        news.data.length &gt; 0 ? (&#10;          &lt;NewsList&gt;&#10;            {news.data.map((item: NewsItem) =&gt; (&#10;              &lt;NewsItemCard key={item.id}&gt;&#10;                &lt;Title&gt;{item.title}&lt;/Title&gt;&#10;                &lt;Content&gt;{item.content}&lt;/Content&gt;&#10;                &lt;CategoryDate&gt;&#10;                  Категория: {item.category} | Дата: {new Date(item.publish_date).toLocaleDateString()}&#10;                &lt;/CategoryDate&gt;&#10;                {item.link &amp;&amp; (&#10;                  &lt;SourceLink href={item.link} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#10;                    Источник&#10;                  &lt;/SourceLink&gt;&#10;                )}&#10;              &lt;/NewsItemCard&gt;&#10;            ))}&#10;          &lt;/NewsList&gt;&#10;        ) : (&#10;          &lt;Message&gt;{news.message}&lt;/Message&gt;&#10;        )&#10;      ) : (&#10;        &lt;Message&gt;Ошибка загрузки новостей&lt;/Message&gt;&#10;      )}&#10;    &lt;/AppContainer&gt;&#10;  );&#10;};&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/giftpropaganda-frontend/src/api/news.ts" />
              <option name="originalContent" value="import axios from 'axios';&#10;&#10;const API_URL = 'https://c614d13bcb7d.ngrok-free.app/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsResponse&gt;(API_URL);&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: 'Ошибка загрузки новостей (frontend)'&#10;    };&#10;  }&#10;};" />
              <option name="updatedContent" value="import axios from 'axios';&#10;&#10;const API_URL = 'https://c614d13bcb7d.ngrok-free.app/api/news/';&#10;&#10;export interface NewsItem {&#10;  id: number;&#10;  title: string;&#10;  content: string;&#10;  link: string;&#10;  publish_date: string;&#10;  category: string;&#10;}&#10;&#10;export interface NewsResponse {&#10;  status: string;&#10;  data: NewsItem[];&#10;  message: string;&#10;}&#10;&#10;export const fetchNews = async (): Promise&lt;NewsResponse&gt; =&gt; {&#10;  try {&#10;    const response = await axios.get&lt;NewsResponse&gt;(API_URL, {&#10;      headers: {&#10;        'ngrok-skip-browser-warning': 'true'&#10;      }&#10;    });&#10;    console.log('API response:', response.data);&#10;    return response.data;&#10;  } catch (error: any) {&#10;    console.error('Ошибка при загрузке новостей:', error);&#10;    return {&#10;      status: 'error',&#10;      data: [],&#10;      message: 'Ошибка загрузки новостей (frontend)'&#10;    };&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="fastapi==0.104.1&#10;uvicorn[standard]==0.24.0&#10;sqlalchemy==2.0.23&#10;python-dotenv==1.0.0&#10;requests==2.31.0&#10;apscheduler==3.10.4&#10;aiohttp==3.9.1&#10;feedparser==6.0.10&#10;pydantic==2.5.0&#10;psycopg2-binary==2.9.9" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/.env" />
              <option name="updatedContent" value="# База данных&#10;DATABASE_URL=postgresql://user:password@db:5432/giftpropaganda&#10;&#10;# Telegram Bot&#10;TELEGRAM_BOT_TOKEN=your_bot_token_here&#10;WEBHOOK_URL=https://your-domain.com/telegram_webhook&#10;&#10;# Redis (опционально)&#10;REDIS_URL=redis://localhost:6379&#10;&#10;# Другие настройки&#10;DEBUG=False&#10;LOG_LEVEL=INFO" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/__init__.py" />
              <option name="updatedContent" value="# Server package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/__init__.py" />
              <option name="updatedContent" value="# API package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/api/news.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/api/news.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.main import app&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    SessionLocal = app.state.SessionLocal&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;import logging&#10;from server.models import NewsItem&#10;from server.db import SessionLocal  # Импортируем SessionLocal из db.py&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;router = APIRouter(prefix=&quot;/api/news&quot;, tags=[&quot;news&quot;])&#10;&#10;def get_db():&#10;    db = SessionLocal()&#10;    try:&#10;        yield db&#10;    finally:&#10;        db.close()&#10;&#10;@router.get(&quot;/&quot;)&#10;async def get_news(category: str = &quot;all&quot;, limit: int = 50, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Получить новости&quot;&quot;&quot;&#10;    try:&#10;        query = db.query(NewsItem)&#10;        if category != &quot;all&quot;:&#10;            query = query.filter(NewsItem.category == category)&#10;        news = query.order_by(NewsItem.publish_date.desc()).limit(limit).all()&#10;        data = [&#10;            {&#10;                &quot;id&quot;: item.id,&#10;                &quot;title&quot;: item.title,&#10;                &quot;content&quot;: item.content,&#10;                &quot;link&quot;: item.link,&#10;                &quot;publish_date&quot;: item.publish_date.isoformat() if item.publish_date else None,&#10;                &quot;category&quot;: item.category&#10;            }&#10;            for item in news&#10;        ]&#10;        return {&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;data&quot;: data,&#10;            &quot;message&quot;: &quot;Новости успешно получены&quot; if data else &quot;Нет новостей&quot;&#10;        }&#10;    except Exception as e:&#10;        logger.error(f&quot;Error getting news: {e}&quot;)&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to fetch news&quot;)&#10;&#10;@router.get(&quot;/categories&quot;)&#10;async def get_categories():&#10;    &quot;&quot;&quot;Получить категории новостей&quot;&quot;&quot;&#10;    return {&#10;        &quot;status&quot;: &quot;success&quot;,&#10;        &quot;categories&quot;: [&quot;gifts&quot;, &quot;crypto&quot;, &quot;nft&quot;, &quot;tech&quot;, &quot;general&quot;]&#10;    }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/config.py" />
              <option name="originalContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://user:password@db:5432/giftpropaganda&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)&#10;" />
              <option name="updatedContent" value="from dotenv import load_dotenv&#10;import os&#10;&#10;load_dotenv()&#10;&#10;# Настройки базы данных - исправлено для соответствия docker-compose.yml&#10;DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;, &quot;postgresql://user:password@db:5432/giftpropaganda&quot;)&#10;&#10;# Настройки Telegram Bot&#10;TOKEN = os.getenv(&quot;TELEGRAM_BOT_TOKEN&quot;, &quot;&quot;)&#10;WEBHOOK_URL = os.getenv(&quot;WEBHOOK_URL&quot;, &quot;&quot;)&#10;&#10;# Настройки Redis (если используется)&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379&quot;)&#10;&#10;# Другие настройки&#10;DEBUG = os.getenv(&quot;DEBUG&quot;, &quot;False&quot;).lower() == &quot;true&quot;&#10;LOG_LEVEL = os.getenv(&quot;LOG_LEVEL&quot;, &quot;INFO&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/db.py" />
              <option name="updatedContent" value="from sqlalchemy import create_engine&#10;from sqlalchemy.orm import sessionmaker&#10;from server.config import DATABASE_URL&#10;from server.models import Base&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;&#10;# Создание таблиц (если нужно)&#10;Base.metadata.create_all(bind=engine)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/main.py" />
              <option name="originalContent" value="from fastapi import FastAPI, Request&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: WEBHOOK_URL}&#10;    response = requests.post(url, data=data)&#10;    if response.status_code == 200:&#10;        logger.info(&quot;Webhook установлен успешно&quot;)&#10;    else:&#10;        logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal  # Сохраняем SessionLocal&#10;    setup_webhook()&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()  # Создаём новую сессию&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()  # Закрываем сессию&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()  # Корректно закрываем engine&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
              <option name="updatedContent" value="from fastapi import FastAPI, Request&#10;from fastapi.middleware.cors import CORSMiddleware&#10;from sqlalchemy import create_engine, text&#10;from sqlalchemy.orm import sessionmaker&#10;from sqlalchemy.exc import OperationalError&#10;from server.models import Base&#10;from server.parsers.telegram import  fetch_telegram_channels&#10;from server.api.news import router as news_router&#10;import requests&#10;import asyncio&#10;import time&#10;import logging&#10;from server.config import DATABASE_URL, TOKEN, WEBHOOK_URL&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;app = FastAPI()&#10;&#10;# Добавляем CORS middleware&#10;app.add_middleware(&#10;    CORSMiddleware,&#10;    allow_origins=[&quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:3000&quot;],  # Разрешаем запросы с фронтенда&#10;    allow_credentials=True,&#10;    allow_methods=[&quot;*&quot;],  # Разрешаем все HTTP методы&#10;    allow_headers=[&quot;*&quot;],  # Разрешаем все заголовки&#10;)&#10;&#10;# Настройка базы данных с повторными попытками&#10;def init_db():&#10;    max_retries = 10&#10;    retry_delay = 5  # 5 секунд между попытками&#10;    for i in range(max_retries):&#10;        try:&#10;            engine = create_engine(DATABASE_URL)&#10;            with engine.connect() as connection:&#10;                connection.execute(text(&quot;SELECT 1&quot;))  # Проверка подключения&#10;            SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)&#10;            Base.metadata.create_all(bind=engine)&#10;            logger.info(&quot;База данных инициализирована успешно&quot;)&#10;            return engine, SessionLocal&#10;        except OperationalError as e:&#10;            logger.warning(f&quot;Попытка {i+1}/{max_retries} подключения к базе: {e}&quot;)&#10;            if i &lt; max_retries - 1:&#10;                time.sleep(retry_delay)&#10;            else:&#10;                raise Exception(&quot;Не удалось подключиться к базе данных после нескольких попыток&quot;)&#10;&#10;def setup_webhook():&#10;    &quot;&quot;&quot;Настройка вебхука для Telegram&quot;&quot;&quot;&#10;    url = f&quot;https://api.telegram.org/bot{TOKEN}/setWebhook&quot;&#10;    data = {&quot;url&quot;: WEBHOOK_URL}&#10;    response = requests.post(url, data=data)&#10;    if response.status_code == 200:&#10;        logger.info(&quot;Webhook установлен успешно&quot;)&#10;    else:&#10;        logger.error(f&quot;Ошибка установки вебхука: {response.text}&quot;)&#10;&#10;@app.on_event(&quot;startup&quot;)&#10;async def startup_event():&#10;    &quot;&quot;&quot;Событие при запуске приложения&quot;&quot;&quot;&#10;    engine, SessionLocal = init_db()&#10;    app.state.engine = engine&#10;    app.state.SessionLocal = SessionLocal  # Сохраняем SessionLocal&#10;    setup_webhook()&#10;    loop = asyncio.get_running_loop()&#10;    loop.create_task(periodic_fetch())&#10;&#10;async def periodic_fetch():&#10;    &quot;&quot;&quot;Периодическое обновление новостей из Telegram-каналов&quot;&quot;&quot;&#10;    while True:&#10;        session = app.state.SessionLocal()  # Создаём новую сессию&#10;        try:&#10;            await fetch_telegram_channels(session)&#10;            logger.info(&quot;Периодическое обновление завершено&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Ошибка при периодическом обновлении: {e}&quot;)&#10;        finally:&#10;            session.close()  # Закрываем сессию&#10;        await asyncio.sleep(1800)  # 30 минут&#10;&#10;@app.on_event(&quot;shutdown&quot;)&#10;async def shutdown_event():&#10;    &quot;&quot;&quot;Событие при остановке приложения&quot;&quot;&quot;&#10;    if hasattr(app.state, 'engine'):&#10;        app.state.engine.dispose()  # Корректно закрываем engine&#10;        logger.info(&quot;База данных закрыта успешно&quot;)&#10;&#10;app.include_router(news_router)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import uvicorn&#10;    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models.py" />
              <option name="originalContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;))  # Внешний ключ&#10;    title = Column(String(200), index=True)&#10;    content = Column(String)&#10;    link = Column(String(255))&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации&#10;" />
              <option name="updatedContent" value="from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;&#10;Base = declarative_base()&#10;&#10;class Source(Base):&#10;    __tablename__ = &quot;sources&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    type = Column(String(50), nullable=False)  # &quot;telegram&quot; или &quot;rss&quot;&#10;    url = Column(String(500))  # URL для RSS или username для Telegram&#10;    name = Column(String(200), nullable=False)&#10;    chat_id = Column(String(100), nullable=True)  # Для Telegram-каналов с ботом-админом&#10;    category = Column(String(50), default=&quot;general&quot;)  # gifts, crypto, nft, tech, general&#10;    enabled = Column(Integer, default=1)  # 1 = включен, 0 = отключен&#10;&#10;    # Связь с новостями&#10;    news_items = relationship(&quot;NewsItem&quot;, back_populates=&quot;source&quot;)&#10;&#10;&#10;class NewsItem(Base):&#10;    __tablename__ = &quot;news_items&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    source_id = Column(Integer, ForeignKey(&quot;sources.id&quot;), nullable=True)  # Внешний ключ теперь допускает NULL&#10;    title = Column(String(200), index=True)&#10;    content = Column(String)&#10;    link = Column(String(255))&#10;    publish_date = Column(DateTime)&#10;    category = Column(String(50))&#10;    source = relationship(&quot;Source&quot;, back_populates=&quot;news_items&quot;)&#10;&#10;class Keyword(Base):&#10;    __tablename__ = &quot;keywords&quot;&#10;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    category = Column(String(50), nullable=False)&#10;    keyword = Column(String(100), nullable=False)&#10;    weight = Column(Integer, default=1)  # Вес ключевого слова для категоризации" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/__init__.py" />
              <option name="updatedContent" value="# Parsers package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/parsers/rss.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/parsers/rss.py" />
              <option name="updatedContent" value="import feedparser&#10;import logging&#10;from sqlalchemy.orm import Session&#10;from typing import List, Dict, Any&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;async def fetch_rss_feeds(session: Session) -&gt; List[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Получение новостей из RSS источников&quot;&quot;&quot;&#10;    try:&#10;        logger.info(&quot;Fetching RSS feeds...&quot;)&#10;        &#10;        # Список RSS источников&#10;        rss_sources = [&#10;            {&quot;url&quot;: &quot;https://vc.ru/rss&quot;, &quot;name&quot;: &quot;VC.ru&quot;, &quot;category&quot;: &quot;tech&quot;},&#10;            {&quot;url&quot;: &quot;https://forklog.com/feed/&quot;, &quot;name&quot;: &quot;ForkLog&quot;, &quot;category&quot;: &quot;crypto&quot;}&#10;        ]&#10;        &#10;        articles = []&#10;        for source in rss_sources:&#10;            try:&#10;                feed = feedparser.parse(source[&quot;url&quot;])&#10;                for entry in feed.entries[:5]:  # Берем только 5 последних&#10;                    article = {&#10;                        &quot;title&quot;: entry.title,&#10;                        &quot;link&quot;: entry.link,&#10;                        &quot;description&quot;: getattr(entry, 'summary', ''),&#10;                        &quot;source&quot;: source[&quot;name&quot;],&#10;                        &quot;category&quot;: source[&quot;category&quot;]&#10;                    }&#10;                    articles.append(article)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error parsing RSS {source['url']}: {e}&quot;)&#10;        &#10;        logger.info(f&quot;RSS feeds fetched successfully, {len(articles)} articles&quot;)&#10;        return articles&#10;        &#10;    except Exception as e:&#10;        logger.error(f&quot;Error fetching RSS feeds: {e}&quot;)&#10;        return []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/utils/categorize.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/utils/categorize.py" />
              <option name="updatedContent" value="import re&#10;from typing import List, Dict&#10;&#10;def categorize_content(title: str, content: str = &quot;&quot;) -&gt; str:&#10;    &quot;&quot;&quot;Автоматическая категоризация контента по ключевым словам&quot;&quot;&quot;&#10;    &#10;    # Ключевые слова для категорий&#10;    keywords = {&#10;        'gifts': ['подарок', 'подарки', 'бесплатно', 'халява', 'промокод', 'скидка', 'акция', 'розыгрыш'],&#10;        'crypto': ['криптовалюта', 'биткоин', 'bitcoin', 'ethereum', 'блокчейн', 'деф', 'defi', 'btc', 'eth'],&#10;        'nft': ['nft', 'нфт', 'токен', 'коллекция', 'opensea', 'digital art', 'метавселенная'],&#10;        'tech': ['технологии', 'it', 'ит', 'программирование', 'разработка', 'стартап', 'ai', 'ии']&#10;    }&#10;    &#10;    text = (title + &quot; &quot; + content).lower()&#10;    &#10;    # Подсчитываем совпадения для каждой категории&#10;    category_scores = {}&#10;    for category, words in keywords.items():&#10;        score = sum(1 for word in words if word in text)&#10;        if score &gt; 0:&#10;            category_scores[category] = score&#10;    &#10;    if not category_scores:&#10;        return 'general'&#10;    &#10;    # Возвращаем категорию с наибольшим количеством совпадений&#10;    return max(category_scores, key=category_scores.get)&#10;&#10;def extract_keywords(text: str) -&gt; List[str]:&#10;    &quot;&quot;&quot;Извлечение ключевых слов из текста&quot;&quot;&quot;&#10;    # Простое извлечение слов длиннее 3 символов&#10;    words = re.findall(r'\b\w{4,}\b', text.lower())&#10;    return list(set(words))  # Уникальные слова" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>